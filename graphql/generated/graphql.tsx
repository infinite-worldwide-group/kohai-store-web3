import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
import * as React from 'react';
import * as ApolloReactComponents from '@apollo/client/react/components';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  ISO8601DateTime: { input: any; output: any; }
  JSON: { input: any; output: any; }
};

/** Autogenerated return type of AuthenticateWallet. */
export type AuthenticateWalletPayload = {
  __typename?: 'AuthenticateWalletPayload';
  errors: Array<Scalars['String']['output']>;
  token?: Maybe<Scalars['String']['output']>;
  user?: Maybe<User>;
};

/** Autogenerated return type of CreateGameAccount. */
export type CreateGameAccountPayload = {
  __typename?: 'CreateGameAccountPayload';
  errors: Array<Scalars['String']['output']>;
  gameAccount?: Maybe<GameAccount>;
};

/** Autogenerated return type of CreateOrder. */
export type CreateOrderPayload = {
  __typename?: 'CreateOrderPayload';
  errors: Array<Scalars['String']['output']>;
  order?: Maybe<Order>;
};

export type CryptoTransaction = {
  __typename?: 'CryptoTransaction';
  amount?: Maybe<Scalars['Float']['output']>;
  confirmations?: Maybe<Scalars['Int']['output']>;
  createdAt: Scalars['ISO8601DateTime']['output'];
  direction: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  network: Scalars['String']['output'];
  state: Scalars['String']['output'];
  token: Scalars['String']['output'];
  transactionSignature: Scalars['String']['output'];
  transactionType: Scalars['String']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
  verifiedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  walletFrom?: Maybe<Scalars['String']['output']>;
  walletTo?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated return type of DeleteGameAccount. */
export type DeleteGameAccountPayload = {
  __typename?: 'DeleteGameAccountPayload';
  errors: Array<Scalars['String']['output']>;
  success: Scalars['Boolean']['output'];
};

/** A game account linked to a user */
export type GameAccount = {
  __typename?: 'GameAccount';
  accountId?: Maybe<Scalars['String']['output']>;
  approve: Scalars['Boolean']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  displayName: Scalars['String']['output'];
  gameId?: Maybe<Scalars['Int']['output']>;
  id: Scalars['ID']['output'];
  inGameName?: Maybe<Scalars['String']['output']>;
  lastPurchaseAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  serverId?: Maybe<Scalars['String']['output']>;
  status: Scalars['String']['output'];
  topupProduct?: Maybe<TopupProduct>;
  topupProductId?: Maybe<Scalars['Int']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  userData?: Maybe<Scalars['JSON']['output']>;
  userId: Scalars['Int']['output'];
};

/** Payment gateway types */
export enum Gateway {
  /** Cryptocurrency payment (SOL, USDC, USDT) */
  Crypto = 'CRYPTO',
  /** Fiat currency payment */
  Fiat = 'FIAT'
}

/** Autogenerated return type of GenerateNonce. */
export type GenerateNoncePayload = {
  __typename?: 'GenerateNoncePayload';
  errors: Array<Scalars['String']['output']>;
  message: Scalars['String']['output'];
  nonce: Scalars['String']['output'];
};

export type Mutation = {
  __typename?: 'Mutation';
  /** Authenticate user with wallet address */
  authenticateWallet?: Maybe<AuthenticateWalletPayload>;
  /** Create or update a game account for the current user */
  createGameAccount?: Maybe<CreateGameAccountPayload>;
  /** Create an order with verified crypto payment */
  createOrder?: Maybe<CreateOrderPayload>;
  /** Disable a game account (soft delete) */
  deleteGameAccount?: Maybe<DeleteGameAccountPayload>;
  /** Generate a nonce for wallet authentication */
  generateNonce?: Maybe<GenerateNoncePayload>;
  purchaseGameCredit?: Maybe<PurchaseGameCreditPayload>;
  /** Send a verification code to the user's email address */
  sendEmailVerificationCode?: Maybe<SendEmailVerificationCodePayload>;
  /** Update and re-verify user's email address */
  updateEmail?: Maybe<UpdateEmailPayload>;
  /** Validate a game account with the vendor */
  validateGameAccountMutation?: Maybe<ValidateGameAccountMutationPayload>;
  /** Verify user's email with the 6-digit code */
  verifyEmail?: Maybe<VerifyEmailPayload>;
};


export type MutationAuthenticateWalletArgs = {
  message?: InputMaybe<Scalars['String']['input']>;
  signature?: InputMaybe<Scalars['String']['input']>;
  walletAddress: Scalars['String']['input'];
};


export type MutationCreateGameAccountArgs = {
  accountId: Scalars['String']['input'];
  inGameName?: InputMaybe<Scalars['String']['input']>;
  serverId?: InputMaybe<Scalars['String']['input']>;
  topupProductId?: InputMaybe<Scalars['Int']['input']>;
  userData?: InputMaybe<Scalars['JSON']['input']>;
};


export type MutationCreateOrderArgs = {
  cryptoAmount?: InputMaybe<Scalars['Float']['input']>;
  cryptoCurrency?: InputMaybe<Scalars['String']['input']>;
  gameAccountId?: InputMaybe<Scalars['ID']['input']>;
  topupProductItemId: Scalars['ID']['input'];
  transactionSignature: Scalars['String']['input'];
  userData?: InputMaybe<Scalars['JSON']['input']>;
};


export type MutationDeleteGameAccountArgs = {
  gameAccountId: Scalars['Int']['input'];
};


export type MutationGenerateNonceArgs = {
  walletAddress: Scalars['String']['input'];
};


export type MutationPurchaseGameCreditArgs = {
  input: PurchaseGameCreditInput;
};


export type MutationSendEmailVerificationCodeArgs = {
  email: Scalars['String']['input'];
};


export type MutationUpdateEmailArgs = {
  newEmail: Scalars['String']['input'];
};


export type MutationValidateGameAccountMutationArgs = {
  gameAccountId: Scalars['Int']['input'];
};


export type MutationVerifyEmailArgs = {
  code: Scalars['String']['input'];
};

export type Order = {
  __typename?: 'Order';
  /** Final amount in fiat currency (USD, MYR, etc.) */
  amount: Scalars['Float']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Amount paid in cryptocurrency */
  cryptoAmount?: Maybe<Scalars['Float']['output']>;
  /** Cryptocurrency used (SOL, USDT, etc.) */
  cryptoCurrency?: Maybe<Scalars['String']['output']>;
  cryptoTransaction?: Maybe<CryptoTransaction>;
  /** Fiat currency (USD, MYR, etc.) */
  currency: Scalars['String']['output'];
  /** Discount amount */
  discountAmount?: Maybe<Scalars['Float']['output']>;
  /** Discount percentage */
  discountPercent?: Maybe<Scalars['Float']['output']>;
  id: Scalars['ID']['output'];
  metadata?: Maybe<Scalars['JSON']['output']>;
  orderNumber: Scalars['String']['output'];
  orderType: Scalars['String']['output'];
  /** Original amount before discount */
  originalAmount?: Maybe<Scalars['Float']['output']>;
  status: Scalars['String']['output'];
  /** User's VIP tier at purchase */
  tierAtPurchase?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  user: User;
  userData?: Maybe<Scalars['JSON']['output']>;
};

export type PurchaseGameCreditInput = {
  channel?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  gateway: Gateway;
  itemId: Scalars['String']['input'];
  name: Scalars['String']['input'];
  productId: Scalars['String']['input'];
  redirectUrl: Scalars['String']['input'];
  signature: Scalars['String']['input'];
  storeId: Scalars['ID']['input'];
  userInputs: Array<UserInputTypeInput>;
};

/** Autogenerated return type of PurchaseGameCredit. */
export type PurchaseGameCreditPayload = {
  __typename?: 'PurchaseGameCreditPayload';
  message?: Maybe<Scalars['String']['output']>;
  orderNumber?: Maybe<Scalars['String']['output']>;
};

export type Query = {
  __typename?: 'Query';
  /** Get the currently authenticated user */
  currentUser?: Maybe<User>;
  /** Get all game accounts for the current user */
  myGameAccounts: Array<GameAccount>;
  /** Get orders for the current user */
  myOrders: Array<Order>;
  /** Get an order by ID */
  order?: Maybe<Order>;
  /** Get a single topup product by ID or slug */
  topupProduct?: Maybe<TopupProduct>;
  /** Get all topup products with filtering */
  topupProducts: Array<TopupProduct>;
  /** Check transaction status on blockchain */
  transactionStatus?: Maybe<TransactionStatus>;
};


export type QueryMyGameAccountsArgs = {
  approvedOnly?: InputMaybe<Scalars['Boolean']['input']>;
  recentPurchasesOnly?: InputMaybe<Scalars['Boolean']['input']>;
  topupProductId?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryMyOrdersArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryOrderArgs = {
  id: Scalars['ID']['input'];
};


export type QueryTopupProductArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
};


export type QueryTopupProductsArgs = {
  categoryId?: InputMaybe<Scalars['ID']['input']>;
  countryCode?: InputMaybe<Scalars['String']['input']>;
  forStore?: InputMaybe<Scalars['Boolean']['input']>;
  genre?: InputMaybe<Scalars['String']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  perPage?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
};


export type QueryTransactionStatusArgs = {
  signature: Scalars['String']['input'];
};

/** Autogenerated return type of SendEmailVerificationCode. */
export type SendEmailVerificationCodePayload = {
  __typename?: 'SendEmailVerificationCodePayload';
  errors: Array<Scalars['String']['output']>;
  message: Scalars['String']['output'];
  success: Scalars['Boolean']['output'];
};

/** A game topup product */
export type TopupProduct = {
  __typename?: 'TopupProduct';
  active: Scalars['Boolean']['output'];
  avatarUrl?: Maybe<Scalars['String']['output']>;
  category?: Maybe<Scalars['String']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  countryCodes: Array<Scalars['String']['output']>;
  createdAt: Scalars['ISO8601DateTime']['output'];
  description?: Maybe<Scalars['String']['output']>;
  featured: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  isActive: Scalars['Boolean']['output'];
  logoUrl?: Maybe<Scalars['String']['output']>;
  originId?: Maybe<Scalars['String']['output']>;
  publisher?: Maybe<Scalars['String']['output']>;
  publisherLogoUrl?: Maybe<Scalars['String']['output']>;
  slug?: Maybe<Scalars['String']['output']>;
  title: Scalars['String']['output'];
  /** Available items/packages for this product */
  topupProductItems: Array<TopupProductItem>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  userInput?: Maybe<Scalars['JSON']['output']>;
  vendor?: Maybe<Scalars['JSON']['output']>;
  vendorId?: Maybe<Scalars['ID']['output']>;
};

/** A topup product item (denomination/package) */
export type TopupProductItem = {
  __typename?: 'TopupProductItem';
  active: Scalars['Boolean']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  displayName: Scalars['String']['output'];
  formattedPrice: Scalars['String']['output'];
  icon?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
  originId?: Maybe<Scalars['String']['output']>;
  price?: Maybe<Scalars['Float']['output']>;
  topupProductId: Scalars['ID']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type TransactionStatus = {
  __typename?: 'TransactionStatus';
  confirmations: Scalars['Int']['output'];
  error?: Maybe<Scalars['String']['output']>;
  signature: Scalars['String']['output'];
  status: Scalars['String']['output'];
};

/** Autogenerated return type of UpdateEmail. */
export type UpdateEmailPayload = {
  __typename?: 'UpdateEmailPayload';
  errors: Array<Scalars['String']['output']>;
  message: Scalars['String']['output'];
  success: Scalars['Boolean']['output'];
};

export type User = {
  __typename?: 'User';
  createdAt: Scalars['ISO8601DateTime']['output'];
  email?: Maybe<Scalars['String']['output']>;
  emailVerified: Scalars['Boolean']['output'];
  emailVerifiedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  id: Scalars['ID']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
  walletAddress: Scalars['String']['output'];
};

export type UserInputTypeInput = {
  name: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

/** Autogenerated return type of ValidateGameAccountMutation. */
export type ValidateGameAccountMutationPayload = {
  __typename?: 'ValidateGameAccountMutationPayload';
  errors: Array<Scalars['String']['output']>;
  gameAccount?: Maybe<GameAccount>;
  success: Scalars['Boolean']['output'];
};

/** Autogenerated return type of VerifyEmail. */
export type VerifyEmailPayload = {
  __typename?: 'VerifyEmailPayload';
  errors: Array<Scalars['String']['output']>;
  message: Scalars['String']['output'];
  success: Scalars['Boolean']['output'];
  user?: Maybe<User>;
};

export type GameAccountFieldsFragment = { __typename?: 'GameAccount', id: string, accountId?: string | null, serverId?: string | null, inGameName?: string | null, approve: boolean, displayName: string, status: string, userData?: any | null, createdAt: any, updatedAt: any, topupProduct?: { __typename?: 'TopupProduct', id: string, title: string, slug?: string | null } | null };

export type OrderFragment = { __typename?: 'Order', id: string, orderNumber: string, amount: number, currency: string, cryptoAmount?: number | null, cryptoCurrency?: string | null, status: string, orderType: string, metadata?: any | null, createdAt: any, updatedAt: any, cryptoTransaction?: { __typename?: 'CryptoTransaction', id: string, amount?: number | null, token: string, network: string, transactionSignature: string, transactionType: string, confirmations?: number | null, state: string, direction: string, createdAt: any } | null };

export type TopupProductFragment = { __typename?: 'TopupProduct', id: string, originId?: string | null, title: string, description?: string | null, code?: string | null, countryCodes: Array<string>, featured: boolean, publisher?: string | null, isActive: boolean, logoUrl?: string | null, avatarUrl?: string | null, publisherLogoUrl?: string | null, slug?: string | null, category?: string | null, userInput?: any | null, vendorId?: string | null, topupProductItems: Array<{ __typename?: 'TopupProductItem', id: string, name?: string | null, displayName: string, icon?: string | null, price?: number | null, formattedPrice: string, active: boolean, originId?: string | null, topupProductId: string }> };

export type TopupProductDetailFragment = { __typename?: 'TopupProduct', id: string, slug?: string | null, originId?: string | null, title: string, description?: string | null, code?: string | null, countryCodes: Array<string>, featured: boolean, publisher?: string | null, isActive: boolean, logoUrl?: string | null, avatarUrl?: string | null, publisherLogoUrl?: string | null, category?: string | null, userInput?: any | null, vendorId?: string | null, topupProductItems: Array<{ __typename?: 'TopupProductItem', id: string, name?: string | null, displayName: string, icon?: string | null, price?: number | null, formattedPrice: string, active: boolean, originId?: string | null, topupProductId: string }> };

export type TopupProductListFragment = { __typename?: 'TopupProduct', id: string, originId?: string | null, slug?: string | null, title: string, featured: boolean, publisher?: string | null, logoUrl?: string | null, avatarUrl?: string | null, publisherLogoUrl?: string | null, countryCodes: Array<string>, category?: string | null };

export type TopupProductItemFragment = { __typename?: 'TopupProductItem', id: string, name?: string | null, displayName: string, icon?: string | null, price?: number | null, formattedPrice: string, active: boolean, originId?: string | null, topupProductId: string };

export type UserSessionFragment = { __typename?: 'User', id: string, email?: string | null, emailVerified: boolean, emailVerifiedAt?: any | null, updatedAt: any };

export type AuthenticateWalletMutationVariables = Exact<{
  walletAddress: Scalars['String']['input'];
  signature?: InputMaybe<Scalars['String']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
}>;


export type AuthenticateWalletMutation = { __typename?: 'Mutation', authenticateWallet?: { __typename?: 'AuthenticateWalletPayload', token?: string | null, errors: Array<string>, user?: { __typename?: 'User', id: string, email?: string | null, emailVerified: boolean, emailVerifiedAt?: any | null, updatedAt: any } | null } | null };

export type CreateGameAccountMutationVariables = Exact<{
  topupProductId: Scalars['Int']['input'];
  accountId: Scalars['String']['input'];
  serverId?: InputMaybe<Scalars['String']['input']>;
  inGameName?: InputMaybe<Scalars['String']['input']>;
  userData: Scalars['JSON']['input'];
}>;


export type CreateGameAccountMutation = { __typename?: 'Mutation', createGameAccount?: { __typename?: 'CreateGameAccountPayload', errors: Array<string>, gameAccount?: { __typename?: 'GameAccount', id: string, accountId?: string | null, serverId?: string | null, inGameName?: string | null, approve: boolean, displayName: string, userData?: any | null, createdAt: any, topupProduct?: { __typename?: 'TopupProduct', id: string, title: string, slug?: string | null } | null } | null } | null };

export type CreateOrderMutationVariables = Exact<{
  topupProductItemId: Scalars['ID']['input'];
  transactionSignature: Scalars['String']['input'];
  userData?: InputMaybe<Scalars['JSON']['input']>;
}>;


export type CreateOrderMutation = { __typename?: 'Mutation', createOrder?: { __typename?: 'CreateOrderPayload', errors: Array<string>, order?: { __typename?: 'Order', id: string, orderNumber: string, amount: number, currency: string, cryptoAmount?: number | null, cryptoCurrency?: string | null, status: string, orderType: string, metadata?: any | null, createdAt: any, updatedAt: any, cryptoTransaction?: { __typename?: 'CryptoTransaction', id: string, amount?: number | null, token: string, network: string, transactionSignature: string, transactionType: string, confirmations?: number | null, state: string, direction: string, createdAt: any } | null } | null } | null };

export type DeleteGameAccountMutationVariables = Exact<{
  gameAccountId: Scalars['Int']['input'];
}>;


export type DeleteGameAccountMutation = { __typename?: 'Mutation', deleteGameAccount?: { __typename?: 'DeleteGameAccountPayload', success: boolean, errors: Array<string> } | null };

export type SendEmailVerificationCodeMutationVariables = Exact<{
  email: Scalars['String']['input'];
}>;


export type SendEmailVerificationCodeMutation = { __typename?: 'Mutation', sendEmailVerificationCode?: { __typename?: 'SendEmailVerificationCodePayload', success: boolean, message: string, errors: Array<string> } | null };

export type UpdateEmailMutationVariables = Exact<{
  newEmail: Scalars['String']['input'];
}>;


export type UpdateEmailMutation = { __typename?: 'Mutation', updateEmail?: { __typename?: 'UpdateEmailPayload', success: boolean, message: string, errors: Array<string> } | null };

export type ValidateGameAccountMutationVariables = Exact<{
  gameAccountId: Scalars['Int']['input'];
}>;


export type ValidateGameAccountMutation = { __typename?: 'Mutation', validateGameAccountMutation?: { __typename?: 'ValidateGameAccountMutationPayload', success: boolean, errors: Array<string>, gameAccount?: { __typename?: 'GameAccount', id: string, accountId?: string | null, serverId?: string | null, inGameName?: string | null, approve: boolean, displayName: string } | null } | null };

export type VerifyEmailMutationVariables = Exact<{
  code: Scalars['String']['input'];
}>;


export type VerifyEmailMutation = { __typename?: 'Mutation', verifyEmail?: { __typename?: 'VerifyEmailPayload', success: boolean, message: string, errors: Array<string>, user?: { __typename?: 'User', id: string, email?: string | null, emailVerified: boolean, emailVerifiedAt?: any | null, updatedAt: any } | null } | null };

export type CurrentUserQueryVariables = Exact<{ [key: string]: never; }>;


export type CurrentUserQuery = { __typename?: 'Query', currentUser?: { __typename?: 'User', id: string, email?: string | null, emailVerified: boolean, emailVerifiedAt?: any | null, updatedAt: any } | null };

export type MyGameAccountsQueryVariables = Exact<{
  topupProductId?: InputMaybe<Scalars['Int']['input']>;
  approvedOnly?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type MyGameAccountsQuery = { __typename?: 'Query', myGameAccounts: Array<{ __typename?: 'GameAccount', id: string, accountId?: string | null, serverId?: string | null, inGameName?: string | null, approve: boolean, displayName: string, status: string, userData?: any | null, createdAt: any, updatedAt: any, topupProduct?: { __typename?: 'TopupProduct', id: string, title: string, slug?: string | null } | null }> };

export type MyOrdersQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type MyOrdersQuery = { __typename?: 'Query', myOrders: Array<{ __typename?: 'Order', id: string, orderNumber: string, amount: number, currency: string, cryptoAmount?: number | null, cryptoCurrency?: string | null, status: string, orderType: string, metadata?: any | null, createdAt: any, updatedAt: any, cryptoTransaction?: { __typename?: 'CryptoTransaction', id: string, amount?: number | null, token: string, network: string, transactionSignature: string, transactionType: string, confirmations?: number | null, state: string, direction: string, createdAt: any } | null }> };

export type OrderQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type OrderQuery = { __typename?: 'Query', order?: { __typename?: 'Order', id: string, orderNumber: string, amount: number, currency: string, cryptoAmount?: number | null, cryptoCurrency?: string | null, status: string, orderType: string, metadata?: any | null, createdAt: any, updatedAt: any, cryptoTransaction?: { __typename?: 'CryptoTransaction', id: string, amount?: number | null, token: string, network: string, transactionSignature: string, transactionType: string, confirmations?: number | null, state: string, direction: string, createdAt: any } | null } | null };

export type TopupProductsQueryVariables = Exact<{
  categoryId?: InputMaybe<Scalars['ID']['input']>;
  page: Scalars['Int']['input'];
  search?: InputMaybe<Scalars['String']['input']>;
  perPage?: InputMaybe<Scalars['Int']['input']>;
  countryCode?: InputMaybe<Scalars['String']['input']>;
  forStore?: InputMaybe<Scalars['Boolean']['input']>;
  genre?: InputMaybe<Scalars['String']['input']>;
}>;


export type TopupProductsQuery = { __typename?: 'Query', topupProducts: Array<{ __typename?: 'TopupProduct', id: string, originId?: string | null, slug?: string | null, title: string, featured: boolean, publisher?: string | null, logoUrl?: string | null, avatarUrl?: string | null, publisherLogoUrl?: string | null, countryCodes: Array<string>, category?: string | null }> };

export type TopupProductQueryVariables = Exact<{
  id?: InputMaybe<Scalars['ID']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
}>;


export type TopupProductQuery = { __typename?: 'Query', topupProduct?: { __typename?: 'TopupProduct', id: string, originId?: string | null, title: string, description?: string | null, code?: string | null, countryCodes: Array<string>, featured: boolean, publisher?: string | null, isActive: boolean, logoUrl?: string | null, avatarUrl?: string | null, publisherLogoUrl?: string | null, slug?: string | null, category?: string | null, userInput?: any | null, vendorId?: string | null, topupProductItems: Array<{ __typename?: 'TopupProductItem', id: string, name?: string | null, displayName: string, icon?: string | null, price?: number | null, formattedPrice: string, active: boolean, originId?: string | null, topupProductId: string }> } | null };

export type StoreTopupProductQueryVariables = Exact<{
  id?: InputMaybe<Scalars['ID']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
}>;


export type StoreTopupProductQuery = { __typename?: 'Query', topupProduct?: { __typename?: 'TopupProduct', id: string, slug?: string | null, originId?: string | null, title: string, description?: string | null, code?: string | null, countryCodes: Array<string>, featured: boolean, publisher?: string | null, isActive: boolean, logoUrl?: string | null, avatarUrl?: string | null, publisherLogoUrl?: string | null, category?: string | null, userInput?: any | null, vendorId?: string | null, topupProductItems: Array<{ __typename?: 'TopupProductItem', id: string, name?: string | null, displayName: string, icon?: string | null, price?: number | null, formattedPrice: string, active: boolean, originId?: string | null, topupProductId: string }> } | null };

export const GameAccountFieldsFragmentDoc = gql`
    fragment GameAccountFields on GameAccount {
  id
  accountId
  serverId
  inGameName
  approve
  displayName
  status
  userData
  topupProduct {
    id
    title
    slug
  }
  createdAt
  updatedAt
}
    `;
export const OrderFragmentDoc = gql`
    fragment Order on Order {
  id
  orderNumber
  amount
  currency
  cryptoAmount
  cryptoCurrency
  status
  orderType
  metadata
  createdAt
  updatedAt
  cryptoTransaction {
    id
    amount
    token
    network
    transactionSignature
    transactionType
    confirmations
    state
    direction
    createdAt
  }
}
    `;
export const TopupProductItemFragmentDoc = gql`
    fragment TopupProductItem on TopupProductItem {
  id
  name
  displayName
  icon
  price
  formattedPrice
  active
  originId
  topupProductId
}
    `;
export const TopupProductFragmentDoc = gql`
    fragment TopupProduct on TopupProduct {
  id
  originId
  title
  description
  code
  countryCodes
  featured
  publisher
  isActive
  logoUrl
  avatarUrl
  publisherLogoUrl
  slug
  category
  userInput
  vendorId
  topupProductItems {
    ...TopupProductItem
  }
}
    ${TopupProductItemFragmentDoc}`;
export const TopupProductDetailFragmentDoc = gql`
    fragment TopupProductDetail on TopupProduct {
  id
  slug
  originId
  title
  description
  code
  countryCodes
  featured
  publisher
  isActive
  logoUrl
  avatarUrl
  publisherLogoUrl
  category
  userInput
  vendorId
  topupProductItems {
    ...TopupProductItem
  }
}
    ${TopupProductItemFragmentDoc}`;
export const TopupProductListFragmentDoc = gql`
    fragment TopupProductList on TopupProduct {
  id
  originId
  slug
  title
  featured
  publisher
  logoUrl
  avatarUrl
  publisherLogoUrl
  countryCodes
  category
}
    `;
export const UserSessionFragmentDoc = gql`
    fragment UserSession on User {
  id
  email
  emailVerified
  emailVerifiedAt
  updatedAt
}
    `;
export const AuthenticateWalletDocument = gql`
    mutation AuthenticateWallet($walletAddress: String!, $signature: String, $message: String) {
  authenticateWallet(
    walletAddress: $walletAddress
    signature: $signature
    message: $message
  ) {
    user {
      ...UserSession
    }
    token
    errors
  }
}
    ${UserSessionFragmentDoc}`;
export type AuthenticateWalletMutationFn = Apollo.MutationFunction<AuthenticateWalletMutation, AuthenticateWalletMutationVariables>;
export type AuthenticateWalletComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<AuthenticateWalletMutation, AuthenticateWalletMutationVariables>, 'mutation'>;

    export const AuthenticateWalletComponent = (props: AuthenticateWalletComponentProps) => (
      <ApolloReactComponents.Mutation<AuthenticateWalletMutation, AuthenticateWalletMutationVariables> mutation={AuthenticateWalletDocument} {...props} />
    );
    

/**
 * __useAuthenticateWalletMutation__
 *
 * To run a mutation, you first call `useAuthenticateWalletMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAuthenticateWalletMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [authenticateWalletMutation, { data, loading, error }] = useAuthenticateWalletMutation({
 *   variables: {
 *      walletAddress: // value for 'walletAddress'
 *      signature: // value for 'signature'
 *      message: // value for 'message'
 *   },
 * });
 */
export function useAuthenticateWalletMutation(baseOptions?: Apollo.MutationHookOptions<AuthenticateWalletMutation, AuthenticateWalletMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AuthenticateWalletMutation, AuthenticateWalletMutationVariables>(AuthenticateWalletDocument, options);
      }
export type AuthenticateWalletMutationHookResult = ReturnType<typeof useAuthenticateWalletMutation>;
export type AuthenticateWalletMutationResult = Apollo.MutationResult<AuthenticateWalletMutation>;
export type AuthenticateWalletMutationOptions = Apollo.BaseMutationOptions<AuthenticateWalletMutation, AuthenticateWalletMutationVariables>;
export const CreateGameAccountDocument = gql`
    mutation CreateGameAccount($topupProductId: Int!, $accountId: String!, $serverId: String, $inGameName: String, $userData: JSON!) {
  createGameAccount(
    topupProductId: $topupProductId
    accountId: $accountId
    serverId: $serverId
    inGameName: $inGameName
    userData: $userData
  ) {
    gameAccount {
      id
      accountId
      serverId
      inGameName
      approve
      displayName
      userData
      topupProduct {
        id
        title
        slug
      }
      createdAt
    }
    errors
  }
}
    `;
export type CreateGameAccountMutationFn = Apollo.MutationFunction<CreateGameAccountMutation, CreateGameAccountMutationVariables>;
export type CreateGameAccountComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<CreateGameAccountMutation, CreateGameAccountMutationVariables>, 'mutation'>;

    export const CreateGameAccountComponent = (props: CreateGameAccountComponentProps) => (
      <ApolloReactComponents.Mutation<CreateGameAccountMutation, CreateGameAccountMutationVariables> mutation={CreateGameAccountDocument} {...props} />
    );
    

/**
 * __useCreateGameAccountMutation__
 *
 * To run a mutation, you first call `useCreateGameAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateGameAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createGameAccountMutation, { data, loading, error }] = useCreateGameAccountMutation({
 *   variables: {
 *      topupProductId: // value for 'topupProductId'
 *      accountId: // value for 'accountId'
 *      serverId: // value for 'serverId'
 *      inGameName: // value for 'inGameName'
 *      userData: // value for 'userData'
 *   },
 * });
 */
export function useCreateGameAccountMutation(baseOptions?: Apollo.MutationHookOptions<CreateGameAccountMutation, CreateGameAccountMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateGameAccountMutation, CreateGameAccountMutationVariables>(CreateGameAccountDocument, options);
      }
export type CreateGameAccountMutationHookResult = ReturnType<typeof useCreateGameAccountMutation>;
export type CreateGameAccountMutationResult = Apollo.MutationResult<CreateGameAccountMutation>;
export type CreateGameAccountMutationOptions = Apollo.BaseMutationOptions<CreateGameAccountMutation, CreateGameAccountMutationVariables>;
export const CreateOrderDocument = gql`
    mutation CreateOrder($topupProductItemId: ID!, $transactionSignature: String!, $userData: JSON) {
  createOrder(
    topupProductItemId: $topupProductItemId
    transactionSignature: $transactionSignature
    userData: $userData
  ) {
    errors
    order {
      ...Order
    }
  }
}
    ${OrderFragmentDoc}`;
export type CreateOrderMutationFn = Apollo.MutationFunction<CreateOrderMutation, CreateOrderMutationVariables>;
export type CreateOrderComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<CreateOrderMutation, CreateOrderMutationVariables>, 'mutation'>;

    export const CreateOrderComponent = (props: CreateOrderComponentProps) => (
      <ApolloReactComponents.Mutation<CreateOrderMutation, CreateOrderMutationVariables> mutation={CreateOrderDocument} {...props} />
    );
    

/**
 * __useCreateOrderMutation__
 *
 * To run a mutation, you first call `useCreateOrderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOrderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOrderMutation, { data, loading, error }] = useCreateOrderMutation({
 *   variables: {
 *      topupProductItemId: // value for 'topupProductItemId'
 *      transactionSignature: // value for 'transactionSignature'
 *      userData: // value for 'userData'
 *   },
 * });
 */
export function useCreateOrderMutation(baseOptions?: Apollo.MutationHookOptions<CreateOrderMutation, CreateOrderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateOrderMutation, CreateOrderMutationVariables>(CreateOrderDocument, options);
      }
export type CreateOrderMutationHookResult = ReturnType<typeof useCreateOrderMutation>;
export type CreateOrderMutationResult = Apollo.MutationResult<CreateOrderMutation>;
export type CreateOrderMutationOptions = Apollo.BaseMutationOptions<CreateOrderMutation, CreateOrderMutationVariables>;
export const DeleteGameAccountDocument = gql`
    mutation DeleteGameAccount($gameAccountId: Int!) {
  deleteGameAccount(gameAccountId: $gameAccountId) {
    success
    errors
  }
}
    `;
export type DeleteGameAccountMutationFn = Apollo.MutationFunction<DeleteGameAccountMutation, DeleteGameAccountMutationVariables>;
export type DeleteGameAccountComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<DeleteGameAccountMutation, DeleteGameAccountMutationVariables>, 'mutation'>;

    export const DeleteGameAccountComponent = (props: DeleteGameAccountComponentProps) => (
      <ApolloReactComponents.Mutation<DeleteGameAccountMutation, DeleteGameAccountMutationVariables> mutation={DeleteGameAccountDocument} {...props} />
    );
    

/**
 * __useDeleteGameAccountMutation__
 *
 * To run a mutation, you first call `useDeleteGameAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteGameAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteGameAccountMutation, { data, loading, error }] = useDeleteGameAccountMutation({
 *   variables: {
 *      gameAccountId: // value for 'gameAccountId'
 *   },
 * });
 */
export function useDeleteGameAccountMutation(baseOptions?: Apollo.MutationHookOptions<DeleteGameAccountMutation, DeleteGameAccountMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteGameAccountMutation, DeleteGameAccountMutationVariables>(DeleteGameAccountDocument, options);
      }
export type DeleteGameAccountMutationHookResult = ReturnType<typeof useDeleteGameAccountMutation>;
export type DeleteGameAccountMutationResult = Apollo.MutationResult<DeleteGameAccountMutation>;
export type DeleteGameAccountMutationOptions = Apollo.BaseMutationOptions<DeleteGameAccountMutation, DeleteGameAccountMutationVariables>;
export const SendEmailVerificationCodeDocument = gql`
    mutation SendEmailVerificationCode($email: String!) {
  sendEmailVerificationCode(email: $email) {
    success
    message
    errors
  }
}
    `;
export type SendEmailVerificationCodeMutationFn = Apollo.MutationFunction<SendEmailVerificationCodeMutation, SendEmailVerificationCodeMutationVariables>;
export type SendEmailVerificationCodeComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<SendEmailVerificationCodeMutation, SendEmailVerificationCodeMutationVariables>, 'mutation'>;

    export const SendEmailVerificationCodeComponent = (props: SendEmailVerificationCodeComponentProps) => (
      <ApolloReactComponents.Mutation<SendEmailVerificationCodeMutation, SendEmailVerificationCodeMutationVariables> mutation={SendEmailVerificationCodeDocument} {...props} />
    );
    

/**
 * __useSendEmailVerificationCodeMutation__
 *
 * To run a mutation, you first call `useSendEmailVerificationCodeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSendEmailVerificationCodeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sendEmailVerificationCodeMutation, { data, loading, error }] = useSendEmailVerificationCodeMutation({
 *   variables: {
 *      email: // value for 'email'
 *   },
 * });
 */
export function useSendEmailVerificationCodeMutation(baseOptions?: Apollo.MutationHookOptions<SendEmailVerificationCodeMutation, SendEmailVerificationCodeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SendEmailVerificationCodeMutation, SendEmailVerificationCodeMutationVariables>(SendEmailVerificationCodeDocument, options);
      }
export type SendEmailVerificationCodeMutationHookResult = ReturnType<typeof useSendEmailVerificationCodeMutation>;
export type SendEmailVerificationCodeMutationResult = Apollo.MutationResult<SendEmailVerificationCodeMutation>;
export type SendEmailVerificationCodeMutationOptions = Apollo.BaseMutationOptions<SendEmailVerificationCodeMutation, SendEmailVerificationCodeMutationVariables>;
export const UpdateEmailDocument = gql`
    mutation UpdateEmail($newEmail: String!) {
  updateEmail(newEmail: $newEmail) {
    success
    message
    errors
  }
}
    `;
export type UpdateEmailMutationFn = Apollo.MutationFunction<UpdateEmailMutation, UpdateEmailMutationVariables>;
export type UpdateEmailComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<UpdateEmailMutation, UpdateEmailMutationVariables>, 'mutation'>;

    export const UpdateEmailComponent = (props: UpdateEmailComponentProps) => (
      <ApolloReactComponents.Mutation<UpdateEmailMutation, UpdateEmailMutationVariables> mutation={UpdateEmailDocument} {...props} />
    );
    

/**
 * __useUpdateEmailMutation__
 *
 * To run a mutation, you first call `useUpdateEmailMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateEmailMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateEmailMutation, { data, loading, error }] = useUpdateEmailMutation({
 *   variables: {
 *      newEmail: // value for 'newEmail'
 *   },
 * });
 */
export function useUpdateEmailMutation(baseOptions?: Apollo.MutationHookOptions<UpdateEmailMutation, UpdateEmailMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateEmailMutation, UpdateEmailMutationVariables>(UpdateEmailDocument, options);
      }
export type UpdateEmailMutationHookResult = ReturnType<typeof useUpdateEmailMutation>;
export type UpdateEmailMutationResult = Apollo.MutationResult<UpdateEmailMutation>;
export type UpdateEmailMutationOptions = Apollo.BaseMutationOptions<UpdateEmailMutation, UpdateEmailMutationVariables>;
export const ValidateGameAccountDocument = gql`
    mutation ValidateGameAccount($gameAccountId: Int!) {
  validateGameAccountMutation(gameAccountId: $gameAccountId) {
    gameAccount {
      id
      accountId
      serverId
      inGameName
      approve
      displayName
    }
    success
    errors
  }
}
    `;
export type ValidateGameAccountMutationFn = Apollo.MutationFunction<ValidateGameAccountMutation, ValidateGameAccountMutationVariables>;
export type ValidateGameAccountComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<ValidateGameAccountMutation, ValidateGameAccountMutationVariables>, 'mutation'>;

    export const ValidateGameAccountComponent = (props: ValidateGameAccountComponentProps) => (
      <ApolloReactComponents.Mutation<ValidateGameAccountMutation, ValidateGameAccountMutationVariables> mutation={ValidateGameAccountDocument} {...props} />
    );
    

/**
 * __useValidateGameAccountMutation__
 *
 * To run a mutation, you first call `useValidateGameAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useValidateGameAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [validateGameAccountMutation, { data, loading, error }] = useValidateGameAccountMutation({
 *   variables: {
 *      gameAccountId: // value for 'gameAccountId'
 *   },
 * });
 */
export function useValidateGameAccountMutation(baseOptions?: Apollo.MutationHookOptions<ValidateGameAccountMutation, ValidateGameAccountMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ValidateGameAccountMutation, ValidateGameAccountMutationVariables>(ValidateGameAccountDocument, options);
      }
export type ValidateGameAccountMutationHookResult = ReturnType<typeof useValidateGameAccountMutation>;
export type ValidateGameAccountMutationResult = Apollo.MutationResult<ValidateGameAccountMutation>;
export type ValidateGameAccountMutationOptions = Apollo.BaseMutationOptions<ValidateGameAccountMutation, ValidateGameAccountMutationVariables>;
export const VerifyEmailDocument = gql`
    mutation VerifyEmail($code: String!) {
  verifyEmail(code: $code) {
    success
    message
    errors
    user {
      ...UserSession
    }
  }
}
    ${UserSessionFragmentDoc}`;
export type VerifyEmailMutationFn = Apollo.MutationFunction<VerifyEmailMutation, VerifyEmailMutationVariables>;
export type VerifyEmailComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<VerifyEmailMutation, VerifyEmailMutationVariables>, 'mutation'>;

    export const VerifyEmailComponent = (props: VerifyEmailComponentProps) => (
      <ApolloReactComponents.Mutation<VerifyEmailMutation, VerifyEmailMutationVariables> mutation={VerifyEmailDocument} {...props} />
    );
    

/**
 * __useVerifyEmailMutation__
 *
 * To run a mutation, you first call `useVerifyEmailMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useVerifyEmailMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [verifyEmailMutation, { data, loading, error }] = useVerifyEmailMutation({
 *   variables: {
 *      code: // value for 'code'
 *   },
 * });
 */
export function useVerifyEmailMutation(baseOptions?: Apollo.MutationHookOptions<VerifyEmailMutation, VerifyEmailMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<VerifyEmailMutation, VerifyEmailMutationVariables>(VerifyEmailDocument, options);
      }
export type VerifyEmailMutationHookResult = ReturnType<typeof useVerifyEmailMutation>;
export type VerifyEmailMutationResult = Apollo.MutationResult<VerifyEmailMutation>;
export type VerifyEmailMutationOptions = Apollo.BaseMutationOptions<VerifyEmailMutation, VerifyEmailMutationVariables>;
export const CurrentUserDocument = gql`
    query CurrentUser {
  currentUser {
    ...UserSession
  }
}
    ${UserSessionFragmentDoc}`;
export type CurrentUserComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<CurrentUserQuery, CurrentUserQueryVariables>, 'query'>;

    export const CurrentUserComponent = (props: CurrentUserComponentProps) => (
      <ApolloReactComponents.Query<CurrentUserQuery, CurrentUserQueryVariables> query={CurrentUserDocument} {...props} />
    );
    

/**
 * __useCurrentUserQuery__
 *
 * To run a query within a React component, call `useCurrentUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useCurrentUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCurrentUserQuery({
 *   variables: {
 *   },
 * });
 */
export function useCurrentUserQuery(baseOptions?: Apollo.QueryHookOptions<CurrentUserQuery, CurrentUserQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CurrentUserQuery, CurrentUserQueryVariables>(CurrentUserDocument, options);
      }
export function useCurrentUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CurrentUserQuery, CurrentUserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CurrentUserQuery, CurrentUserQueryVariables>(CurrentUserDocument, options);
        }
export function useCurrentUserSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<CurrentUserQuery, CurrentUserQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CurrentUserQuery, CurrentUserQueryVariables>(CurrentUserDocument, options);
        }
export type CurrentUserQueryHookResult = ReturnType<typeof useCurrentUserQuery>;
export type CurrentUserLazyQueryHookResult = ReturnType<typeof useCurrentUserLazyQuery>;
export type CurrentUserSuspenseQueryHookResult = ReturnType<typeof useCurrentUserSuspenseQuery>;
export type CurrentUserQueryResult = Apollo.QueryResult<CurrentUserQuery, CurrentUserQueryVariables>;
export const MyGameAccountsDocument = gql`
    query MyGameAccounts($topupProductId: Int, $approvedOnly: Boolean) {
  myGameAccounts(topupProductId: $topupProductId, approvedOnly: $approvedOnly) {
    id
    accountId
    serverId
    inGameName
    approve
    displayName
    status
    userData
    topupProduct {
      id
      title
      slug
    }
    createdAt
    updatedAt
  }
}
    `;
export type MyGameAccountsComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<MyGameAccountsQuery, MyGameAccountsQueryVariables>, 'query'>;

    export const MyGameAccountsComponent = (props: MyGameAccountsComponentProps) => (
      <ApolloReactComponents.Query<MyGameAccountsQuery, MyGameAccountsQueryVariables> query={MyGameAccountsDocument} {...props} />
    );
    

/**
 * __useMyGameAccountsQuery__
 *
 * To run a query within a React component, call `useMyGameAccountsQuery` and pass it any options that fit your needs.
 * When your component renders, `useMyGameAccountsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyGameAccountsQuery({
 *   variables: {
 *      topupProductId: // value for 'topupProductId'
 *      approvedOnly: // value for 'approvedOnly'
 *   },
 * });
 */
export function useMyGameAccountsQuery(baseOptions?: Apollo.QueryHookOptions<MyGameAccountsQuery, MyGameAccountsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MyGameAccountsQuery, MyGameAccountsQueryVariables>(MyGameAccountsDocument, options);
      }
export function useMyGameAccountsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MyGameAccountsQuery, MyGameAccountsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MyGameAccountsQuery, MyGameAccountsQueryVariables>(MyGameAccountsDocument, options);
        }
export function useMyGameAccountsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<MyGameAccountsQuery, MyGameAccountsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<MyGameAccountsQuery, MyGameAccountsQueryVariables>(MyGameAccountsDocument, options);
        }
export type MyGameAccountsQueryHookResult = ReturnType<typeof useMyGameAccountsQuery>;
export type MyGameAccountsLazyQueryHookResult = ReturnType<typeof useMyGameAccountsLazyQuery>;
export type MyGameAccountsSuspenseQueryHookResult = ReturnType<typeof useMyGameAccountsSuspenseQuery>;
export type MyGameAccountsQueryResult = Apollo.QueryResult<MyGameAccountsQuery, MyGameAccountsQueryVariables>;
export const MyOrdersDocument = gql`
    query MyOrders($limit: Int) {
  myOrders(limit: $limit) {
    ...Order
  }
}
    ${OrderFragmentDoc}`;
export type MyOrdersComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<MyOrdersQuery, MyOrdersQueryVariables>, 'query'>;

    export const MyOrdersComponent = (props: MyOrdersComponentProps) => (
      <ApolloReactComponents.Query<MyOrdersQuery, MyOrdersQueryVariables> query={MyOrdersDocument} {...props} />
    );
    

/**
 * __useMyOrdersQuery__
 *
 * To run a query within a React component, call `useMyOrdersQuery` and pass it any options that fit your needs.
 * When your component renders, `useMyOrdersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyOrdersQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useMyOrdersQuery(baseOptions?: Apollo.QueryHookOptions<MyOrdersQuery, MyOrdersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MyOrdersQuery, MyOrdersQueryVariables>(MyOrdersDocument, options);
      }
export function useMyOrdersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MyOrdersQuery, MyOrdersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MyOrdersQuery, MyOrdersQueryVariables>(MyOrdersDocument, options);
        }
export function useMyOrdersSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<MyOrdersQuery, MyOrdersQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<MyOrdersQuery, MyOrdersQueryVariables>(MyOrdersDocument, options);
        }
export type MyOrdersQueryHookResult = ReturnType<typeof useMyOrdersQuery>;
export type MyOrdersLazyQueryHookResult = ReturnType<typeof useMyOrdersLazyQuery>;
export type MyOrdersSuspenseQueryHookResult = ReturnType<typeof useMyOrdersSuspenseQuery>;
export type MyOrdersQueryResult = Apollo.QueryResult<MyOrdersQuery, MyOrdersQueryVariables>;
export const OrderDocument = gql`
    query Order($id: ID!) {
  order(id: $id) {
    ...Order
  }
}
    ${OrderFragmentDoc}`;
export type OrderComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<OrderQuery, OrderQueryVariables>, 'query'> & ({ variables: OrderQueryVariables; skip?: boolean; } | { skip: boolean; });

    export const OrderComponent = (props: OrderComponentProps) => (
      <ApolloReactComponents.Query<OrderQuery, OrderQueryVariables> query={OrderDocument} {...props} />
    );
    

/**
 * __useOrderQuery__
 *
 * To run a query within a React component, call `useOrderQuery` and pass it any options that fit your needs.
 * When your component renders, `useOrderQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOrderQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useOrderQuery(baseOptions: Apollo.QueryHookOptions<OrderQuery, OrderQueryVariables> & ({ variables: OrderQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<OrderQuery, OrderQueryVariables>(OrderDocument, options);
      }
export function useOrderLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<OrderQuery, OrderQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<OrderQuery, OrderQueryVariables>(OrderDocument, options);
        }
export function useOrderSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<OrderQuery, OrderQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<OrderQuery, OrderQueryVariables>(OrderDocument, options);
        }
export type OrderQueryHookResult = ReturnType<typeof useOrderQuery>;
export type OrderLazyQueryHookResult = ReturnType<typeof useOrderLazyQuery>;
export type OrderSuspenseQueryHookResult = ReturnType<typeof useOrderSuspenseQuery>;
export type OrderQueryResult = Apollo.QueryResult<OrderQuery, OrderQueryVariables>;
export const TopupProductsDocument = gql`
    query TopupProducts($categoryId: ID, $page: Int!, $search: String, $perPage: Int, $countryCode: String, $forStore: Boolean, $genre: String) {
  topupProducts(
    categoryId: $categoryId
    page: $page
    search: $search
    perPage: $perPage
    countryCode: $countryCode
    forStore: $forStore
    genre: $genre
  ) {
    ...TopupProductList
  }
}
    ${TopupProductListFragmentDoc}`;
export type TopupProductsComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<TopupProductsQuery, TopupProductsQueryVariables>, 'query'> & ({ variables: TopupProductsQueryVariables; skip?: boolean; } | { skip: boolean; });

    export const TopupProductsComponent = (props: TopupProductsComponentProps) => (
      <ApolloReactComponents.Query<TopupProductsQuery, TopupProductsQueryVariables> query={TopupProductsDocument} {...props} />
    );
    

/**
 * __useTopupProductsQuery__
 *
 * To run a query within a React component, call `useTopupProductsQuery` and pass it any options that fit your needs.
 * When your component renders, `useTopupProductsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTopupProductsQuery({
 *   variables: {
 *      categoryId: // value for 'categoryId'
 *      page: // value for 'page'
 *      search: // value for 'search'
 *      perPage: // value for 'perPage'
 *      countryCode: // value for 'countryCode'
 *      forStore: // value for 'forStore'
 *      genre: // value for 'genre'
 *   },
 * });
 */
export function useTopupProductsQuery(baseOptions: Apollo.QueryHookOptions<TopupProductsQuery, TopupProductsQueryVariables> & ({ variables: TopupProductsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TopupProductsQuery, TopupProductsQueryVariables>(TopupProductsDocument, options);
      }
export function useTopupProductsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TopupProductsQuery, TopupProductsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TopupProductsQuery, TopupProductsQueryVariables>(TopupProductsDocument, options);
        }
export function useTopupProductsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<TopupProductsQuery, TopupProductsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<TopupProductsQuery, TopupProductsQueryVariables>(TopupProductsDocument, options);
        }
export type TopupProductsQueryHookResult = ReturnType<typeof useTopupProductsQuery>;
export type TopupProductsLazyQueryHookResult = ReturnType<typeof useTopupProductsLazyQuery>;
export type TopupProductsSuspenseQueryHookResult = ReturnType<typeof useTopupProductsSuspenseQuery>;
export type TopupProductsQueryResult = Apollo.QueryResult<TopupProductsQuery, TopupProductsQueryVariables>;
export const TopupProductDocument = gql`
    query TopupProduct($id: ID, $slug: String) {
  topupProduct(id: $id, slug: $slug) {
    ...TopupProduct
  }
}
    ${TopupProductFragmentDoc}`;
export type TopupProductComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<TopupProductQuery, TopupProductQueryVariables>, 'query'>;

    export const TopupProductComponent = (props: TopupProductComponentProps) => (
      <ApolloReactComponents.Query<TopupProductQuery, TopupProductQueryVariables> query={TopupProductDocument} {...props} />
    );
    

/**
 * __useTopupProductQuery__
 *
 * To run a query within a React component, call `useTopupProductQuery` and pass it any options that fit your needs.
 * When your component renders, `useTopupProductQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTopupProductQuery({
 *   variables: {
 *      id: // value for 'id'
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useTopupProductQuery(baseOptions?: Apollo.QueryHookOptions<TopupProductQuery, TopupProductQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TopupProductQuery, TopupProductQueryVariables>(TopupProductDocument, options);
      }
export function useTopupProductLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TopupProductQuery, TopupProductQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TopupProductQuery, TopupProductQueryVariables>(TopupProductDocument, options);
        }
export function useTopupProductSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<TopupProductQuery, TopupProductQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<TopupProductQuery, TopupProductQueryVariables>(TopupProductDocument, options);
        }
export type TopupProductQueryHookResult = ReturnType<typeof useTopupProductQuery>;
export type TopupProductLazyQueryHookResult = ReturnType<typeof useTopupProductLazyQuery>;
export type TopupProductSuspenseQueryHookResult = ReturnType<typeof useTopupProductSuspenseQuery>;
export type TopupProductQueryResult = Apollo.QueryResult<TopupProductQuery, TopupProductQueryVariables>;
export const StoreTopupProductDocument = gql`
    query StoreTopupProduct($id: ID, $slug: String) {
  topupProduct(id: $id, slug: $slug) {
    ...TopupProductDetail
  }
}
    ${TopupProductDetailFragmentDoc}`;
export type StoreTopupProductComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<StoreTopupProductQuery, StoreTopupProductQueryVariables>, 'query'>;

    export const StoreTopupProductComponent = (props: StoreTopupProductComponentProps) => (
      <ApolloReactComponents.Query<StoreTopupProductQuery, StoreTopupProductQueryVariables> query={StoreTopupProductDocument} {...props} />
    );
    

/**
 * __useStoreTopupProductQuery__
 *
 * To run a query within a React component, call `useStoreTopupProductQuery` and pass it any options that fit your needs.
 * When your component renders, `useStoreTopupProductQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStoreTopupProductQuery({
 *   variables: {
 *      id: // value for 'id'
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useStoreTopupProductQuery(baseOptions?: Apollo.QueryHookOptions<StoreTopupProductQuery, StoreTopupProductQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StoreTopupProductQuery, StoreTopupProductQueryVariables>(StoreTopupProductDocument, options);
      }
export function useStoreTopupProductLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StoreTopupProductQuery, StoreTopupProductQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StoreTopupProductQuery, StoreTopupProductQueryVariables>(StoreTopupProductDocument, options);
        }
export function useStoreTopupProductSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<StoreTopupProductQuery, StoreTopupProductQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StoreTopupProductQuery, StoreTopupProductQueryVariables>(StoreTopupProductDocument, options);
        }
export type StoreTopupProductQueryHookResult = ReturnType<typeof useStoreTopupProductQuery>;
export type StoreTopupProductLazyQueryHookResult = ReturnType<typeof useStoreTopupProductLazyQuery>;
export type StoreTopupProductSuspenseQueryHookResult = ReturnType<typeof useStoreTopupProductSuspenseQuery>;
export type StoreTopupProductQueryResult = Apollo.QueryResult<StoreTopupProductQuery, StoreTopupProductQueryVariables>;