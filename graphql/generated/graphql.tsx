import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
import * as React from 'react';
import * as ApolloReactComponents from '@apollo/client/react/components';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  BigInt: { input: any; output: any; }
  ISO8601DateTime: { input: any; output: any; }
  JSON: { input: any; output: any; }
};

/** Autogenerated return type of AddFavorite. */
export type AddFavoritePayload = {
  __typename?: 'AddFavoritePayload';
  errors: Array<Scalars['String']['output']>;
  topupProduct?: Maybe<TopupProduct>;
};

/** Autogenerated return type of ApplyReferralCode. */
export type ApplyReferralCodePayload = {
  __typename?: 'ApplyReferralCodePayload';
  errors: Array<Scalars['String']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  referral?: Maybe<Referral>;
  voucher?: Maybe<Voucher>;
};

/** Autogenerated return type of AuthenticateWallet. */
export type AuthenticateWalletPayload = {
  __typename?: 'AuthenticateWalletPayload';
  errors: Array<Scalars['String']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  token?: Maybe<Scalars['String']['output']>;
  user?: Maybe<User>;
};

export type BadgeInfo = {
  __typename?: 'BadgeInfo';
  color?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated return type of ClaimEarnings. */
export type ClaimEarningsPayload = {
  __typename?: 'ClaimEarningsPayload';
  claimedAmount?: Maybe<Scalars['Float']['output']>;
  errors: Array<Scalars['String']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  transactionSignature?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated return type of ConfirmPayment. */
export type ConfirmPaymentPayload = {
  __typename?: 'ConfirmPaymentPayload';
  cryptoTransaction?: Maybe<CryptoTransaction>;
  errors: Array<Scalars['String']['output']>;
  order?: Maybe<Order>;
  verified: Scalars['Boolean']['output'];
};

/** Autogenerated return type of CreateGameAccount. */
export type CreateGameAccountPayload = {
  __typename?: 'CreateGameAccountPayload';
  errors: Array<Scalars['String']['output']>;
  gameAccount?: Maybe<GameAccount>;
};

/** Autogenerated return type of CreateOrder. */
export type CreateOrderPayload = {
  __typename?: 'CreateOrderPayload';
  errors: Array<Scalars['String']['output']>;
  order?: Maybe<Order>;
};

/** Autogenerated return type of CreateTier. */
export type CreateTierPayload = {
  __typename?: 'CreateTierPayload';
  errors?: Maybe<Array<Scalars['String']['output']>>;
  tier?: Maybe<Tier>;
};

export type CryptoTransaction = {
  __typename?: 'CryptoTransaction';
  /** Transaction amount (may use scientific notation for small values) */
  amount?: Maybe<Scalars['Float']['output']>;
  /** Transaction amount as formatted decimal string */
  amountString?: Maybe<Scalars['String']['output']>;
  confirmations?: Maybe<Scalars['Int']['output']>;
  createdAt: Scalars['ISO8601DateTime']['output'];
  direction: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  network: Scalars['String']['output'];
  state: Scalars['String']['output'];
  token: Scalars['String']['output'];
  transactionSignature: Scalars['String']['output'];
  transactionType: Scalars['String']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
  verifiedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  walletFrom?: Maybe<Scalars['String']['output']>;
  walletTo?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated return type of DeleteGameAccount. */
export type DeleteGameAccountPayload = {
  __typename?: 'DeleteGameAccountPayload';
  errors: Array<Scalars['String']['output']>;
  success: Scalars['Boolean']['output'];
};

/** Autogenerated return type of DeleteTier. */
export type DeleteTierPayload = {
  __typename?: 'DeleteTierPayload';
  errors?: Maybe<Array<Scalars['String']['output']>>;
  message?: Maybe<Scalars['String']['output']>;
  success?: Maybe<Scalars['Boolean']['output']>;
};

/** A fiat currency or stablecoin */
export type FiatCurrency = {
  __typename?: 'FiatCurrency';
  /** Currency code (e.g., USD, MYR, USDT) */
  code: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Number of decimal places */
  decimals: Scalars['Int']['output'];
  /** Formatted display name */
  displayName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  isActive: Scalars['Boolean']['output'];
  isDefault: Scalars['Boolean']['output'];
  /** Full currency name */
  name: Scalars['String']['output'];
  /** Blockchain network (e.g., solana) or null for fiat */
  network?: Maybe<Scalars['String']['output']>;
  /** Currency symbol (e.g., $, RM, à¸¿) */
  symbol: Scalars['String']['output'];
  toUsd: Scalars['Float']['output'];
  /** Token mint address for crypto (null for fiat) */
  tokenMint?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  /** Exchange rate to USD (1 unit of this currency = X USD) */
  usdRate: Scalars['Float']['output'];
};


/** A fiat currency or stablecoin */
export type FiatCurrencyToUsdArgs = {
  amount: Scalars['Float']['input'];
};

/** A game account linked to a user */
export type GameAccount = {
  __typename?: 'GameAccount';
  accountId?: Maybe<Scalars['String']['output']>;
  approve: Scalars['Boolean']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  displayName: Scalars['String']['output'];
  gameId?: Maybe<Scalars['Int']['output']>;
  id: Scalars['ID']['output'];
  inGameName?: Maybe<Scalars['String']['output']>;
  lastPurchaseAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  serverId?: Maybe<Scalars['String']['output']>;
  status: Scalars['String']['output'];
  topupProduct?: Maybe<TopupProduct>;
  topupProductId?: Maybe<Scalars['Int']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  userData?: Maybe<Scalars['JSON']['output']>;
  userId: Scalars['Int']['output'];
};

/** Payment gateway types */
export enum Gateway {
  /** Cryptocurrency payment (SOL, USDC, USDT) */
  Crypto = 'CRYPTO',
  /** Fiat currency payment */
  Fiat = 'FIAT'
}

/** Autogenerated return type of GenerateNonce. */
export type GenerateNoncePayload = {
  __typename?: 'GenerateNoncePayload';
  errors: Array<Scalars['String']['output']>;
  message: Scalars['String']['output'];
  nonce: Scalars['String']['output'];
};

export type Mutation = {
  __typename?: 'Mutation';
  /** Add a product to user's favorites */
  addFavorite?: Maybe<AddFavoritePayload>;
  /** Apply a referral code to receive a welcome voucher */
  applyReferralCode?: Maybe<ApplyReferralCodePayload>;
  /** Authenticate user with wallet address */
  authenticateWallet?: Maybe<AuthenticateWalletPayload>;
  /** Claim accumulated referrer earnings (initiates smart contract transfer) */
  claimEarnings?: Maybe<ClaimEarningsPayload>;
  /** Confirm payment for an order by verifying the Solana transaction */
  confirmPayment?: Maybe<ConfirmPaymentPayload>;
  /** Create or update a game account for the current user */
  createGameAccount?: Maybe<CreateGameAccountPayload>;
  /** Create an order with verified crypto payment */
  createOrder?: Maybe<CreateOrderPayload>;
  /** Create a new tier */
  createTier?: Maybe<CreateTierPayload>;
  /** Disable a game account (soft delete) */
  deleteGameAccount?: Maybe<DeleteGameAccountPayload>;
  /** Delete a tier (soft delete via is_active flag) */
  deleteTier?: Maybe<DeleteTierPayload>;
  /** Generate a nonce for wallet authentication */
  generateNonce?: Maybe<GenerateNoncePayload>;
  purchaseGameCredit?: Maybe<PurchaseGameCreditPayload>;
  /** Remove a product from user's favorites */
  removeFavorite?: Maybe<RemoveFavoritePayload>;
  /** Send a verification code to the user's email address */
  sendEmailVerificationCode?: Maybe<SendEmailVerificationCodePayload>;
  /** Update and re-verify user's email address */
  updateEmail?: Maybe<UpdateEmailPayload>;
  /** Update an existing tier */
  updateTier?: Maybe<UpdateTierPayload>;
  /** Validate a game account with the vendor */
  validateGameAccountMutation?: Maybe<ValidateGameAccountMutationPayload>;
  /** Verify user's email with the 6-digit code */
  verifyEmail?: Maybe<VerifyEmailPayload>;
};


export type MutationAddFavoriteArgs = {
  productId: Scalars['ID']['input'];
};


export type MutationApplyReferralCodeArgs = {
  code: Scalars['String']['input'];
};


export type MutationAuthenticateWalletArgs = {
  email?: InputMaybe<Scalars['String']['input']>;
  emailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  signature?: InputMaybe<Scalars['String']['input']>;
  walletAddress: Scalars['String']['input'];
};


export type MutationConfirmPaymentArgs = {
  orderId: Scalars['ID']['input'];
  transactionSignature: Scalars['String']['input'];
};


export type MutationCreateGameAccountArgs = {
  accountId: Scalars['String']['input'];
  inGameName?: InputMaybe<Scalars['String']['input']>;
  serverId?: InputMaybe<Scalars['String']['input']>;
  topupProductId?: InputMaybe<Scalars['Int']['input']>;
  userData?: InputMaybe<Scalars['JSON']['input']>;
};


export type MutationCreateOrderArgs = {
  cryptoAmount?: InputMaybe<Scalars['Float']['input']>;
  cryptoCurrency?: InputMaybe<Scalars['String']['input']>;
  gameAccountId?: InputMaybe<Scalars['ID']['input']>;
  topupProductItemId: Scalars['ID']['input'];
  transactionSignature: Scalars['String']['input'];
  userData?: InputMaybe<Scalars['JSON']['input']>;
};


export type MutationCreateTierArgs = {
  badgeColor?: InputMaybe<Scalars['String']['input']>;
  badgeName?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  discountPercent: Scalars['Float']['input'];
  displayOrder?: InputMaybe<Scalars['Int']['input']>;
  minimumBalance: Scalars['BigInt']['input'];
  name: Scalars['String']['input'];
  tierKey: Scalars['String']['input'];
};


export type MutationDeleteGameAccountArgs = {
  gameAccountId: Scalars['Int']['input'];
};


export type MutationDeleteTierArgs = {
  id: Scalars['ID']['input'];
};


export type MutationGenerateNonceArgs = {
  walletAddress: Scalars['String']['input'];
};


export type MutationPurchaseGameCreditArgs = {
  input: PurchaseGameCreditInput;
};


export type MutationRemoveFavoriteArgs = {
  productId: Scalars['ID']['input'];
};


export type MutationSendEmailVerificationCodeArgs = {
  email: Scalars['String']['input'];
};


export type MutationUpdateEmailArgs = {
  newEmail: Scalars['String']['input'];
};


export type MutationUpdateTierArgs = {
  badgeColor?: InputMaybe<Scalars['String']['input']>;
  badgeName?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  discountPercent?: InputMaybe<Scalars['Float']['input']>;
  displayOrder?: InputMaybe<Scalars['Int']['input']>;
  id: Scalars['ID']['input'];
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  minimumBalance?: InputMaybe<Scalars['BigInt']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};


export type MutationValidateGameAccountMutationArgs = {
  gameAccountId: Scalars['Int']['input'];
};


export type MutationVerifyEmailArgs = {
  code: Scalars['String']['input'];
};

export type Order = {
  __typename?: 'Order';
  /** Final amount in fiat currency (USD, MYR, etc.) */
  amount: Scalars['Float']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Amount paid in cryptocurrency */
  cryptoAmount?: Maybe<Scalars['Float']['output']>;
  /** Amount paid in cryptocurrency (formatted string) */
  cryptoAmountString?: Maybe<Scalars['String']['output']>;
  /** Cryptocurrency used (SOL, USDT, etc.) */
  cryptoCurrency?: Maybe<Scalars['String']['output']>;
  cryptoTransaction?: Maybe<CryptoTransaction>;
  /** Fiat currency (USD, MYR, etc.) */
  currency: Scalars['String']['output'];
  /** Discount amount */
  discountAmount?: Maybe<Scalars['Float']['output']>;
  /** Discount percentage */
  discountPercent?: Maybe<Scalars['Float']['output']>;
  id: Scalars['ID']['output'];
  metadata?: Maybe<Scalars['JSON']['output']>;
  orderNumber: Scalars['String']['output'];
  orderType: Scalars['String']['output'];
  /** Original amount before discount */
  originalAmount?: Maybe<Scalars['Float']['output']>;
  status: Scalars['String']['output'];
  /** User's VIP tier at purchase */
  tierAtPurchase?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  user: User;
  userData?: Maybe<Scalars['JSON']['output']>;
};

export type PurchaseGameCreditInput = {
  channel?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  gateway: Gateway;
  itemId: Scalars['String']['input'];
  name: Scalars['String']['input'];
  productId: Scalars['String']['input'];
  redirectUrl: Scalars['String']['input'];
  signature: Scalars['String']['input'];
  storeId: Scalars['ID']['input'];
  userInputs: Array<UserInputTypeInput>;
};

/** Autogenerated return type of PurchaseGameCredit. */
export type PurchaseGameCreditPayload = {
  __typename?: 'PurchaseGameCreditPayload';
  message?: Maybe<Scalars['String']['output']>;
  orderNumber?: Maybe<Scalars['String']['output']>;
};

export type Query = {
  __typename?: 'Query';
  activeVouchers: Array<Voucher>;
  /** Convert amount between currencies using live exchange rates */
  convertCurrency: Scalars['Float']['output'];
  /** Get the currently authenticated user */
  currentUser?: Maybe<User>;
  /** Get current user's favorite products */
  myFavorites: Array<TopupProduct>;
  /** Get all game accounts for the current user */
  myGameAccounts: Array<GameAccount>;
  /** Get orders for the current user */
  myOrders: Array<Order>;
  /** Get an order by ID */
  order?: Maybe<Order>;
  referralCode?: Maybe<ReferralCode>;
  referralStats: ReferralStats;
  /** Get all supported currencies with live exchange rates */
  supportedCurrencies: Array<FiatCurrency>;
  /** Get a specific tier by its key */
  tierByKey?: Maybe<Tier>;
  /** Get current user's VIP tier status with optional real-time blockchain check */
  tierStatus: TierStatus;
  /** Get all active tiers */
  tiers: Array<Tier>;
  /** Get a single topup product by ID or slug */
  topupProduct?: Maybe<TopupProduct>;
  /** Get all topup products with filtering */
  topupProducts: Array<TopupProduct>;
  /** Check transaction status on blockchain */
  transactionStatus?: Maybe<TransactionStatus>;
};


export type QueryConvertCurrencyArgs = {
  amount: Scalars['Float']['input'];
  fromCurrency: Scalars['String']['input'];
  toCurrency: Scalars['String']['input'];
};


export type QueryMyGameAccountsArgs = {
  approvedOnly?: InputMaybe<Scalars['Boolean']['input']>;
  recentPurchasesOnly?: InputMaybe<Scalars['Boolean']['input']>;
  topupProductId?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryMyOrdersArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryOrderArgs = {
  id: Scalars['ID']['input'];
};


export type QuerySupportedCurrenciesArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']['input']>;
  network?: InputMaybe<Scalars['String']['input']>;
};


export type QueryTierByKeyArgs = {
  tierKey: Scalars['String']['input'];
};


export type QueryTierStatusArgs = {
  forceRefresh?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryTiersArgs = {
  includeInactive?: InputMaybe<Scalars['Boolean']['input']>;
  sortBy?: InputMaybe<Scalars['String']['input']>;
};


export type QueryTopupProductArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
};


export type QueryTopupProductsArgs = {
  categoryId?: InputMaybe<Scalars['ID']['input']>;
  countryCode?: InputMaybe<Scalars['String']['input']>;
  featuredOnly?: InputMaybe<Scalars['Boolean']['input']>;
  forStore?: InputMaybe<Scalars['Boolean']['input']>;
  genre?: InputMaybe<Scalars['String']['input']>;
  page?: InputMaybe<Scalars['Int']['input']>;
  perPage?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  sortBy?: InputMaybe<Scalars['String']['input']>;
};


export type QueryTransactionStatusArgs = {
  signature: Scalars['String']['input'];
};

export type Referral = {
  __typename?: 'Referral';
  appliedAt: Scalars['ISO8601DateTime']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
};

export type ReferralCode = {
  __typename?: 'ReferralCode';
  code: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  totalEarnings: Scalars['Float']['output'];
  totalUses: Scalars['Int']['output'];
};

export type ReferralStats = {
  __typename?: 'ReferralStats';
  claimableEarnings: Scalars['Float']['output'];
  claimedEarnings: Scalars['Float']['output'];
  recentEarnings: Array<ReferrerEarning>;
  referralCode?: Maybe<Scalars['String']['output']>;
  totalEarnings: Scalars['Float']['output'];
  totalReferrals: Scalars['Int']['output'];
};

export type ReferrerEarning = {
  __typename?: 'ReferrerEarning';
  claimedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  commissionAmount: Scalars['Float']['output'];
  commissionPercent: Scalars['Float']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  currency: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  orderAmount: Scalars['Float']['output'];
  status: Scalars['String']['output'];
};

/** Autogenerated return type of RemoveFavorite. */
export type RemoveFavoritePayload = {
  __typename?: 'RemoveFavoritePayload';
  errors: Array<Scalars['String']['output']>;
  topupProduct?: Maybe<TopupProduct>;
};

/** Autogenerated return type of SendEmailVerificationCode. */
export type SendEmailVerificationCodePayload = {
  __typename?: 'SendEmailVerificationCodePayload';
  errors: Array<Scalars['String']['output']>;
  message: Scalars['String']['output'];
  success: Scalars['Boolean']['output'];
};

export type Tier = {
  __typename?: 'Tier';
  badgeColor?: Maybe<Scalars['String']['output']>;
  badgeName?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  discountPercent?: Maybe<Scalars['Float']['output']>;
  displayName?: Maybe<Scalars['String']['output']>;
  displayOrder?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
  isActive?: Maybe<Scalars['Boolean']['output']>;
  minimumBalance?: Maybe<Scalars['BigInt']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  tierBenefits?: Maybe<TierBenefits>;
  tierKey?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
};

export type TierBenefits = {
  __typename?: 'TierBenefits';
  badge?: Maybe<BadgeInfo>;
  description?: Maybe<Scalars['String']['output']>;
  discountPercent?: Maybe<Scalars['Float']['output']>;
  minimumBalance?: Maybe<Scalars['BigInt']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  tierKey?: Maybe<Scalars['String']['output']>;
};

/** User's VIP tier status information */
export type TierStatus = {
  __typename?: 'TierStatus';
  /** Badge display text */
  badge?: Maybe<Scalars['String']['output']>;
  /** Current $KOHAI token balance */
  balance: Scalars['Float']['output'];
  /** Whether this data is from cache */
  cached: Scalars['Boolean']['output'];
  /** Discount percentage for orders */
  discountPercent: Scalars['Int']['output'];
  /** When tier was last checked */
  lastCheckedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  /** Referral commission percentage */
  referralPercent: Scalars['Int']['output'];
  /** UI style (silver, gold, orange) */
  style?: Maybe<Scalars['String']['output']>;
  /** Tier identifier (elite, grandmaster, legend) */
  tier?: Maybe<Scalars['String']['output']>;
  /** Display name for tier */
  tierName?: Maybe<Scalars['String']['output']>;
};

/** A game topup product */
export type TopupProduct = {
  __typename?: 'TopupProduct';
  active: Scalars['Boolean']['output'];
  avatarUrl?: Maybe<Scalars['String']['output']>;
  category?: Maybe<Scalars['String']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  countryCodes: Array<Scalars['String']['output']>;
  createdAt: Scalars['ISO8601DateTime']['output'];
  description?: Maybe<Scalars['String']['output']>;
  /** Whether this product is featured/priority */
  featured: Scalars['Boolean']['output'];
  /** Base game name (extracted from title) */
  gameName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  isActive: Scalars['Boolean']['output'];
  /** Whether the current user has favorited this product */
  isFavorite: Scalars['Boolean']['output'];
  /** Alias for featured field */
  isPriority: Scalars['Boolean']['output'];
  logoUrl?: Maybe<Scalars['String']['output']>;
  ordering?: Maybe<Scalars['String']['output']>;
  originId?: Maybe<Scalars['String']['output']>;
  publisher?: Maybe<Scalars['String']['output']>;
  publisherLogoUrl?: Maybe<Scalars['String']['output']>;
  /** Region code extracted from title (e.g., MY/SG, PH/TH) */
  regionCode: Scalars['String']['output'];
  slug?: Maybe<Scalars['String']['output']>;
  title: Scalars['String']['output'];
  /** Available items/packages for this product */
  topupProductItems: Array<TopupProductItem>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  userInput?: Maybe<Scalars['JSON']['output']>;
  vendor?: Maybe<Scalars['JSON']['output']>;
  vendorId?: Maybe<Scalars['ID']['output']>;
};

/** A topup product item (denomination/package) */
export type TopupProductItem = {
  __typename?: 'TopupProductItem';
  active: Scalars['Boolean']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  currency: Scalars['String']['output'];
  discountAmount: Scalars['Float']['output'];
  discountPercent: Scalars['Int']['output'];
  discountedPrice: Scalars['Float']['output'];
  discountedPriceUsdt: Scalars['Float']['output'];
  displayName: Scalars['String']['output'];
  formattedPrice: Scalars['String']['output'];
  icon?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
  originId?: Maybe<Scalars['String']['output']>;
  price?: Maybe<Scalars['Float']['output']>;
  priceInUsdt?: Maybe<Scalars['Float']['output']>;
  tierInfo?: Maybe<Scalars['JSON']['output']>;
  topupProductId: Scalars['ID']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type TransactionStatus = {
  __typename?: 'TransactionStatus';
  confirmations: Scalars['Int']['output'];
  error?: Maybe<Scalars['String']['output']>;
  signature: Scalars['String']['output'];
  status: Scalars['String']['output'];
};

/** Autogenerated return type of UpdateEmail. */
export type UpdateEmailPayload = {
  __typename?: 'UpdateEmailPayload';
  errors: Array<Scalars['String']['output']>;
  message: Scalars['String']['output'];
  success: Scalars['Boolean']['output'];
};

/** Autogenerated return type of UpdateTier. */
export type UpdateTierPayload = {
  __typename?: 'UpdateTierPayload';
  errors?: Maybe<Array<Scalars['String']['output']>>;
  tier?: Maybe<Tier>;
};

export type User = {
  __typename?: 'User';
  /** The referral code this user applied (if any) */
  appliedReferralCode?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Current discount percentage */
  discountPercent: Scalars['Int']['output'];
  email?: Maybe<Scalars['String']['output']>;
  emailVerified: Scalars['Boolean']['output'];
  emailVerifiedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  /** Whether user has applied a referral code */
  hasAppliedReferralCode: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** Current $KOHAI token balance */
  kohaiBalance?: Maybe<Scalars['Float']['output']>;
  /** When the referral code was applied */
  referralAppliedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  /** ID of the user who referred them */
  referredById?: Maybe<Scalars['ID']['output']>;
  /** Current VIP tier (elite, grandmaster, legend) */
  tier?: Maybe<Scalars['String']['output']>;
  /** Badge display name */
  tierBadge?: Maybe<Scalars['String']['output']>;
  /** Display name for tier */
  tierName?: Maybe<Scalars['String']['output']>;
  /** UI style (silver, gold, orange) */
  tierStyle?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
  walletAddress: Scalars['String']['output'];
};

export type UserInputTypeInput = {
  name: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

/** Autogenerated return type of ValidateGameAccountMutation. */
export type ValidateGameAccountMutationPayload = {
  __typename?: 'ValidateGameAccountMutationPayload';
  errors: Array<Scalars['String']['output']>;
  gameAccount?: Maybe<GameAccount>;
  success: Scalars['Boolean']['output'];
};

/** Autogenerated return type of VerifyEmail. */
export type VerifyEmailPayload = {
  __typename?: 'VerifyEmailPayload';
  errors: Array<Scalars['String']['output']>;
  message: Scalars['String']['output'];
  success: Scalars['Boolean']['output'];
  user?: Maybe<User>;
};

export type Voucher = {
  __typename?: 'Voucher';
  active: Scalars['Boolean']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  discountPercent: Scalars['Float']['output'];
  expiresAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  used: Scalars['Boolean']['output'];
  usedAt?: Maybe<Scalars['ISO8601DateTime']['output']>;
  voucherType: Scalars['String']['output'];
};

export type GameAccountFieldsFragment = { __typename?: 'GameAccount', id: string, accountId?: string | null, serverId?: string | null, inGameName?: string | null, approve: boolean, displayName: string, status: string, userData?: any | null, createdAt: any, updatedAt: any, topupProduct?: { __typename?: 'TopupProduct', id: string, title: string, slug?: string | null } | null };

export type OrderFragment = { __typename?: 'Order', id: string, orderNumber: string, amount: number, currency: string, cryptoAmount?: number | null, cryptoCurrency?: string | null, status: string, orderType: string, metadata?: any | null, createdAt: any, updatedAt: any, cryptoTransaction?: { __typename?: 'CryptoTransaction', id: string, amount?: number | null, token: string, network: string, transactionSignature: string, transactionType: string, confirmations?: number | null, state: string, direction: string, createdAt: any } | null };

export type TopupProductFragment = { __typename?: 'TopupProduct', id: string, originId?: string | null, title: string, description?: string | null, code?: string | null, countryCodes: Array<string>, featured: boolean, publisher?: string | null, isActive: boolean, logoUrl?: string | null, avatarUrl?: string | null, publisherLogoUrl?: string | null, slug?: string | null, category?: string | null, userInput?: any | null, vendorId?: string | null, isFavorite: boolean, ordering?: string | null, topupProductItems: Array<{ __typename?: 'TopupProductItem', id: string, name?: string | null, displayName: string, icon?: string | null, price?: number | null, currency: string, formattedPrice: string, active: boolean, originId?: string | null, topupProductId: string }> };

export type TopupProductDetailFragment = { __typename?: 'TopupProduct', id: string, slug?: string | null, originId?: string | null, title: string, description?: string | null, code?: string | null, countryCodes: Array<string>, featured: boolean, publisher?: string | null, isActive: boolean, logoUrl?: string | null, avatarUrl?: string | null, publisherLogoUrl?: string | null, category?: string | null, userInput?: any | null, vendorId?: string | null, isFavorite: boolean, ordering?: string | null, topupProductItems: Array<{ __typename?: 'TopupProductItem', id: string, name?: string | null, displayName: string, icon?: string | null, price?: number | null, currency: string, formattedPrice: string, active: boolean, originId?: string | null, topupProductId: string }> };

export type TopupProductListFragment = { __typename?: 'TopupProduct', id: string, originId?: string | null, slug?: string | null, title: string, featured: boolean, publisher?: string | null, logoUrl?: string | null, avatarUrl?: string | null, publisherLogoUrl?: string | null, countryCodes: Array<string>, category?: string | null, isFavorite: boolean, ordering?: string | null };

export type TopupProductItemFragment = { __typename?: 'TopupProductItem', id: string, name?: string | null, displayName: string, icon?: string | null, price?: number | null, currency: string, formattedPrice: string, active: boolean, originId?: string | null, topupProductId: string };

export type UserSessionFragment = { __typename?: 'User', id: string, email?: string | null, emailVerified: boolean, emailVerifiedAt?: any | null, updatedAt: any, walletAddress: string, tier?: string | null, tierName?: string | null, discountPercent: number, kohaiBalance?: number | null, tierBadge?: string | null, tierStyle?: string | null, appliedReferralCode?: string | null, referredById?: string | null };

export type AddFavoriteMutationVariables = Exact<{
  productId: Scalars['ID']['input'];
}>;


export type AddFavoriteMutation = { __typename?: 'Mutation', addFavorite?: { __typename?: 'AddFavoritePayload', errors: Array<string>, topupProduct?: { __typename?: 'TopupProduct', id: string, isFavorite: boolean } | null } | null };

export type ApplyReferralCodeMutationVariables = Exact<{
  code: Scalars['String']['input'];
}>;


export type ApplyReferralCodeMutation = { __typename?: 'Mutation', applyReferralCode?: { __typename?: 'ApplyReferralCodePayload', message?: string | null, errors: Array<string>, referral?: { __typename?: 'Referral', id: string, appliedAt: any } | null, voucher?: { __typename?: 'Voucher', id: string, voucherType: string, discountPercent: number, expiresAt: any, active: boolean } | null } | null };

export type AuthenticateWalletMutationVariables = Exact<{
  walletAddress: Scalars['String']['input'];
  signature?: InputMaybe<Scalars['String']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
}>;


export type AuthenticateWalletMutation = { __typename?: 'Mutation', authenticateWallet?: { __typename?: 'AuthenticateWalletPayload', token?: string | null, errors: Array<string>, user?: { __typename?: 'User', id: string, email?: string | null, emailVerified: boolean, emailVerifiedAt?: any | null, updatedAt: any, walletAddress: string, tier?: string | null, tierName?: string | null, discountPercent: number, kohaiBalance?: number | null, tierBadge?: string | null, tierStyle?: string | null, appliedReferralCode?: string | null, referredById?: string | null } | null } | null };

export type ClaimEarningsMutationVariables = Exact<{ [key: string]: never; }>;


export type ClaimEarningsMutation = { __typename?: 'Mutation', claimEarnings?: { __typename?: 'ClaimEarningsPayload', transactionSignature?: string | null, claimedAmount?: number | null, message?: string | null, errors: Array<string> } | null };

export type CreateGameAccountMutationVariables = Exact<{
  topupProductId: Scalars['Int']['input'];
  accountId: Scalars['String']['input'];
  serverId?: InputMaybe<Scalars['String']['input']>;
  inGameName?: InputMaybe<Scalars['String']['input']>;
  userData: Scalars['JSON']['input'];
}>;


export type CreateGameAccountMutation = { __typename?: 'Mutation', createGameAccount?: { __typename?: 'CreateGameAccountPayload', errors: Array<string>, gameAccount?: { __typename?: 'GameAccount', id: string, accountId?: string | null, serverId?: string | null, inGameName?: string | null, approve: boolean, displayName: string, userData?: any | null, createdAt: any, topupProduct?: { __typename?: 'TopupProduct', id: string, title: string, slug?: string | null } | null } | null } | null };

export type CreateOrderMutationVariables = Exact<{
  topupProductItemId: Scalars['ID']['input'];
  transactionSignature: Scalars['String']['input'];
  userData?: InputMaybe<Scalars['JSON']['input']>;
  cryptoCurrency?: InputMaybe<Scalars['String']['input']>;
  cryptoAmount?: InputMaybe<Scalars['Float']['input']>;
}>;


export type CreateOrderMutation = { __typename?: 'Mutation', createOrder?: { __typename?: 'CreateOrderPayload', errors: Array<string>, order?: { __typename?: 'Order', id: string, orderNumber: string, amount: number, currency: string, cryptoAmount?: number | null, cryptoCurrency?: string | null, status: string, orderType: string, metadata?: any | null, createdAt: any, updatedAt: any, cryptoTransaction?: { __typename?: 'CryptoTransaction', id: string, amount?: number | null, token: string, network: string, transactionSignature: string, transactionType: string, confirmations?: number | null, state: string, direction: string, createdAt: any } | null } | null } | null };

export type DeleteGameAccountMutationVariables = Exact<{
  gameAccountId: Scalars['Int']['input'];
}>;


export type DeleteGameAccountMutation = { __typename?: 'Mutation', deleteGameAccount?: { __typename?: 'DeleteGameAccountPayload', success: boolean, errors: Array<string> } | null };

export type RemoveFavoriteMutationVariables = Exact<{
  productId: Scalars['ID']['input'];
}>;


export type RemoveFavoriteMutation = { __typename?: 'Mutation', removeFavorite?: { __typename?: 'RemoveFavoritePayload', errors: Array<string>, topupProduct?: { __typename?: 'TopupProduct', id: string, isFavorite: boolean } | null } | null };

export type SendEmailVerificationCodeMutationVariables = Exact<{
  email: Scalars['String']['input'];
}>;


export type SendEmailVerificationCodeMutation = { __typename?: 'Mutation', sendEmailVerificationCode?: { __typename?: 'SendEmailVerificationCodePayload', success: boolean, message: string, errors: Array<string> } | null };

export type UpdateEmailMutationVariables = Exact<{
  newEmail: Scalars['String']['input'];
}>;


export type UpdateEmailMutation = { __typename?: 'Mutation', updateEmail?: { __typename?: 'UpdateEmailPayload', success: boolean, message: string, errors: Array<string> } | null };

export type ValidateGameAccountMutationVariables = Exact<{
  gameAccountId: Scalars['Int']['input'];
}>;


export type ValidateGameAccountMutation = { __typename?: 'Mutation', validateGameAccountMutation?: { __typename?: 'ValidateGameAccountMutationPayload', success: boolean, errors: Array<string>, gameAccount?: { __typename?: 'GameAccount', id: string, accountId?: string | null, serverId?: string | null, inGameName?: string | null, approve: boolean, displayName: string } | null } | null };

export type VerifyEmailMutationVariables = Exact<{
  code: Scalars['String']['input'];
}>;


export type VerifyEmailMutation = { __typename?: 'Mutation', verifyEmail?: { __typename?: 'VerifyEmailPayload', success: boolean, message: string, errors: Array<string>, user?: { __typename?: 'User', id: string, email?: string | null, emailVerified: boolean, emailVerifiedAt?: any | null, updatedAt: any, walletAddress: string, tier?: string | null, tierName?: string | null, discountPercent: number, kohaiBalance?: number | null, tierBadge?: string | null, tierStyle?: string | null, appliedReferralCode?: string | null, referredById?: string | null } | null } | null };

export type GetActiveVouchersQueryVariables = Exact<{ [key: string]: never; }>;


export type GetActiveVouchersQuery = { __typename?: 'Query', activeVouchers: Array<{ __typename?: 'Voucher', id: string, voucherType: string, discountPercent: number, expiresAt: any, used: boolean, active: boolean, createdAt: any }> };

export type CurrentUserQueryVariables = Exact<{ [key: string]: never; }>;


export type CurrentUserQuery = { __typename?: 'Query', currentUser?: { __typename?: 'User', id: string, email?: string | null, emailVerified: boolean, emailVerifiedAt?: any | null, updatedAt: any, walletAddress: string, tier?: string | null, tierName?: string | null, discountPercent: number, kohaiBalance?: number | null, tierBadge?: string | null, tierStyle?: string | null, appliedReferralCode?: string | null, referredById?: string | null } | null };

export type MyFavoritesQueryVariables = Exact<{ [key: string]: never; }>;


export type MyFavoritesQuery = { __typename?: 'Query', myFavorites: Array<{ __typename?: 'TopupProduct', id: string, originId?: string | null, slug?: string | null, title: string, featured: boolean, publisher?: string | null, logoUrl?: string | null, avatarUrl?: string | null, publisherLogoUrl?: string | null, countryCodes: Array<string>, category?: string | null, isFavorite: boolean, ordering?: string | null }> };

export type MyGameAccountsQueryVariables = Exact<{
  topupProductId?: InputMaybe<Scalars['Int']['input']>;
  approvedOnly?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type MyGameAccountsQuery = { __typename?: 'Query', myGameAccounts: Array<{ __typename?: 'GameAccount', id: string, accountId?: string | null, serverId?: string | null, inGameName?: string | null, approve: boolean, displayName: string, status: string, userData?: any | null, createdAt: any, updatedAt: any, topupProduct?: { __typename?: 'TopupProduct', id: string, title: string, slug?: string | null } | null }> };

export type MyOrdersQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type MyOrdersQuery = { __typename?: 'Query', myOrders: Array<{ __typename?: 'Order', id: string, orderNumber: string, amount: number, currency: string, cryptoAmount?: number | null, cryptoCurrency?: string | null, status: string, orderType: string, metadata?: any | null, createdAt: any, updatedAt: any, cryptoTransaction?: { __typename?: 'CryptoTransaction', id: string, amount?: number | null, token: string, network: string, transactionSignature: string, transactionType: string, confirmations?: number | null, state: string, direction: string, createdAt: any } | null }> };

export type OrderQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type OrderQuery = { __typename?: 'Query', order?: { __typename?: 'Order', id: string, orderNumber: string, amount: number, currency: string, cryptoAmount?: number | null, cryptoCurrency?: string | null, status: string, orderType: string, metadata?: any | null, createdAt: any, updatedAt: any, cryptoTransaction?: { __typename?: 'CryptoTransaction', id: string, amount?: number | null, token: string, network: string, transactionSignature: string, transactionType: string, confirmations?: number | null, state: string, direction: string, createdAt: any } | null } | null };

export type GetReferralCodeQueryVariables = Exact<{ [key: string]: never; }>;


export type GetReferralCodeQuery = { __typename?: 'Query', referralCode?: { __typename?: 'ReferralCode', id: string, code: string, totalUses: number, totalEarnings: number, createdAt: any } | null };

export type GetReferralStatsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetReferralStatsQuery = { __typename?: 'Query', referralStats: { __typename?: 'ReferralStats', referralCode?: string | null, totalReferrals: number, totalEarnings: number, claimableEarnings: number, claimedEarnings: number, recentEarnings: Array<{ __typename?: 'ReferrerEarning', id: string, orderAmount: number, commissionPercent: number, commissionAmount: number, currency: string, status: string, claimedAt?: any | null, createdAt: any }> } };

export type TopupProductsQueryVariables = Exact<{
  categoryId?: InputMaybe<Scalars['ID']['input']>;
  page: Scalars['Int']['input'];
  search?: InputMaybe<Scalars['String']['input']>;
  perPage?: InputMaybe<Scalars['Int']['input']>;
  countryCode?: InputMaybe<Scalars['String']['input']>;
  forStore?: InputMaybe<Scalars['Boolean']['input']>;
  genre?: InputMaybe<Scalars['String']['input']>;
}>;


export type TopupProductsQuery = { __typename?: 'Query', topupProducts: Array<{ __typename?: 'TopupProduct', id: string, originId?: string | null, slug?: string | null, title: string, featured: boolean, publisher?: string | null, logoUrl?: string | null, avatarUrl?: string | null, publisherLogoUrl?: string | null, countryCodes: Array<string>, category?: string | null, isFavorite: boolean, ordering?: string | null }> };

export type TopupProductQueryVariables = Exact<{
  id?: InputMaybe<Scalars['ID']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
}>;


export type TopupProductQuery = { __typename?: 'Query', topupProduct?: { __typename?: 'TopupProduct', id: string, originId?: string | null, title: string, description?: string | null, code?: string | null, countryCodes: Array<string>, featured: boolean, publisher?: string | null, isActive: boolean, logoUrl?: string | null, avatarUrl?: string | null, publisherLogoUrl?: string | null, slug?: string | null, category?: string | null, userInput?: any | null, vendorId?: string | null, isFavorite: boolean, ordering?: string | null, topupProductItems: Array<{ __typename?: 'TopupProductItem', id: string, name?: string | null, displayName: string, icon?: string | null, price?: number | null, currency: string, formattedPrice: string, active: boolean, originId?: string | null, topupProductId: string }> } | null };

export type StoreTopupProductQueryVariables = Exact<{
  id?: InputMaybe<Scalars['ID']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
}>;


export type StoreTopupProductQuery = { __typename?: 'Query', topupProduct?: { __typename?: 'TopupProduct', id: string, slug?: string | null, originId?: string | null, title: string, description?: string | null, code?: string | null, countryCodes: Array<string>, featured: boolean, publisher?: string | null, isActive: boolean, logoUrl?: string | null, avatarUrl?: string | null, publisherLogoUrl?: string | null, category?: string | null, userInput?: any | null, vendorId?: string | null, isFavorite: boolean, ordering?: string | null, topupProductItems: Array<{ __typename?: 'TopupProductItem', id: string, name?: string | null, displayName: string, icon?: string | null, price?: number | null, currency: string, formattedPrice: string, active: boolean, originId?: string | null, topupProductId: string }> } | null };

export const GameAccountFieldsFragmentDoc = gql`
    fragment GameAccountFields on GameAccount {
  id
  accountId
  serverId
  inGameName
  approve
  displayName
  status
  userData
  topupProduct {
    id
    title
    slug
  }
  createdAt
  updatedAt
}
    `;
export const OrderFragmentDoc = gql`
    fragment Order on Order {
  id
  orderNumber
  amount
  currency
  cryptoAmount
  cryptoCurrency
  status
  orderType
  metadata
  createdAt
  updatedAt
  cryptoTransaction {
    id
    amount
    token
    network
    transactionSignature
    transactionType
    confirmations
    state
    direction
    createdAt
  }
}
    `;
export const TopupProductItemFragmentDoc = gql`
    fragment TopupProductItem on TopupProductItem {
  id
  name
  displayName
  icon
  price
  currency
  formattedPrice
  active
  originId
  topupProductId
}
    `;
export const TopupProductFragmentDoc = gql`
    fragment TopupProduct on TopupProduct {
  id
  originId
  title
  description
  code
  countryCodes
  featured
  publisher
  isActive
  logoUrl
  avatarUrl
  publisherLogoUrl
  slug
  category
  userInput
  vendorId
  isFavorite
  ordering
  topupProductItems {
    ...TopupProductItem
  }
}
    ${TopupProductItemFragmentDoc}`;
export const TopupProductDetailFragmentDoc = gql`
    fragment TopupProductDetail on TopupProduct {
  id
  slug
  originId
  title
  description
  code
  countryCodes
  featured
  publisher
  isActive
  logoUrl
  avatarUrl
  publisherLogoUrl
  category
  userInput
  vendorId
  isFavorite
  ordering
  topupProductItems {
    ...TopupProductItem
  }
}
    ${TopupProductItemFragmentDoc}`;
export const TopupProductListFragmentDoc = gql`
    fragment TopupProductList on TopupProduct {
  id
  originId
  slug
  title
  featured
  publisher
  logoUrl
  avatarUrl
  publisherLogoUrl
  countryCodes
  category
  isFavorite
  ordering
}
    `;
export const UserSessionFragmentDoc = gql`
    fragment UserSession on User {
  id
  email
  emailVerified
  emailVerifiedAt
  updatedAt
  walletAddress
  tier
  tierName
  discountPercent
  kohaiBalance
  tierBadge
  tierStyle
  appliedReferralCode
  referredById
}
    `;
export const AddFavoriteDocument = gql`
    mutation AddFavorite($productId: ID!) {
  addFavorite(productId: $productId) {
    topupProduct {
      id
      isFavorite
    }
    errors
  }
}
    `;
export type AddFavoriteMutationFn = Apollo.MutationFunction<AddFavoriteMutation, AddFavoriteMutationVariables>;
export type AddFavoriteComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<AddFavoriteMutation, AddFavoriteMutationVariables>, 'mutation'>;

    export const AddFavoriteComponent = (props: AddFavoriteComponentProps) => (
      <ApolloReactComponents.Mutation<AddFavoriteMutation, AddFavoriteMutationVariables> mutation={AddFavoriteDocument} {...props} />
    );
    

/**
 * __useAddFavoriteMutation__
 *
 * To run a mutation, you first call `useAddFavoriteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddFavoriteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addFavoriteMutation, { data, loading, error }] = useAddFavoriteMutation({
 *   variables: {
 *      productId: // value for 'productId'
 *   },
 * });
 */
export function useAddFavoriteMutation(baseOptions?: Apollo.MutationHookOptions<AddFavoriteMutation, AddFavoriteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddFavoriteMutation, AddFavoriteMutationVariables>(AddFavoriteDocument, options);
      }
export type AddFavoriteMutationHookResult = ReturnType<typeof useAddFavoriteMutation>;
export type AddFavoriteMutationResult = Apollo.MutationResult<AddFavoriteMutation>;
export type AddFavoriteMutationOptions = Apollo.BaseMutationOptions<AddFavoriteMutation, AddFavoriteMutationVariables>;
export const ApplyReferralCodeDocument = gql`
    mutation ApplyReferralCode($code: String!) {
  applyReferralCode(code: $code) {
    referral {
      id
      appliedAt
    }
    voucher {
      id
      voucherType
      discountPercent
      expiresAt
      active
    }
    message
    errors
  }
}
    `;
export type ApplyReferralCodeMutationFn = Apollo.MutationFunction<ApplyReferralCodeMutation, ApplyReferralCodeMutationVariables>;
export type ApplyReferralCodeComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<ApplyReferralCodeMutation, ApplyReferralCodeMutationVariables>, 'mutation'>;

    export const ApplyReferralCodeComponent = (props: ApplyReferralCodeComponentProps) => (
      <ApolloReactComponents.Mutation<ApplyReferralCodeMutation, ApplyReferralCodeMutationVariables> mutation={ApplyReferralCodeDocument} {...props} />
    );
    

/**
 * __useApplyReferralCodeMutation__
 *
 * To run a mutation, you first call `useApplyReferralCodeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApplyReferralCodeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [applyReferralCodeMutation, { data, loading, error }] = useApplyReferralCodeMutation({
 *   variables: {
 *      code: // value for 'code'
 *   },
 * });
 */
export function useApplyReferralCodeMutation(baseOptions?: Apollo.MutationHookOptions<ApplyReferralCodeMutation, ApplyReferralCodeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ApplyReferralCodeMutation, ApplyReferralCodeMutationVariables>(ApplyReferralCodeDocument, options);
      }
export type ApplyReferralCodeMutationHookResult = ReturnType<typeof useApplyReferralCodeMutation>;
export type ApplyReferralCodeMutationResult = Apollo.MutationResult<ApplyReferralCodeMutation>;
export type ApplyReferralCodeMutationOptions = Apollo.BaseMutationOptions<ApplyReferralCodeMutation, ApplyReferralCodeMutationVariables>;
export const AuthenticateWalletDocument = gql`
    mutation AuthenticateWallet($walletAddress: String!, $signature: String, $message: String, $email: String) {
  authenticateWallet(
    walletAddress: $walletAddress
    signature: $signature
    message: $message
    email: $email
  ) {
    user {
      ...UserSession
    }
    token
    errors
  }
}
    ${UserSessionFragmentDoc}`;
export type AuthenticateWalletMutationFn = Apollo.MutationFunction<AuthenticateWalletMutation, AuthenticateWalletMutationVariables>;
export type AuthenticateWalletComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<AuthenticateWalletMutation, AuthenticateWalletMutationVariables>, 'mutation'>;

    export const AuthenticateWalletComponent = (props: AuthenticateWalletComponentProps) => (
      <ApolloReactComponents.Mutation<AuthenticateWalletMutation, AuthenticateWalletMutationVariables> mutation={AuthenticateWalletDocument} {...props} />
    );
    

/**
 * __useAuthenticateWalletMutation__
 *
 * To run a mutation, you first call `useAuthenticateWalletMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAuthenticateWalletMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [authenticateWalletMutation, { data, loading, error }] = useAuthenticateWalletMutation({
 *   variables: {
 *      walletAddress: // value for 'walletAddress'
 *      signature: // value for 'signature'
 *      message: // value for 'message'
 *      email: // value for 'email'
 *   },
 * });
 */
export function useAuthenticateWalletMutation(baseOptions?: Apollo.MutationHookOptions<AuthenticateWalletMutation, AuthenticateWalletMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AuthenticateWalletMutation, AuthenticateWalletMutationVariables>(AuthenticateWalletDocument, options);
      }
export type AuthenticateWalletMutationHookResult = ReturnType<typeof useAuthenticateWalletMutation>;
export type AuthenticateWalletMutationResult = Apollo.MutationResult<AuthenticateWalletMutation>;
export type AuthenticateWalletMutationOptions = Apollo.BaseMutationOptions<AuthenticateWalletMutation, AuthenticateWalletMutationVariables>;
export const ClaimEarningsDocument = gql`
    mutation ClaimEarnings {
  claimEarnings {
    transactionSignature
    claimedAmount
    message
    errors
  }
}
    `;
export type ClaimEarningsMutationFn = Apollo.MutationFunction<ClaimEarningsMutation, ClaimEarningsMutationVariables>;
export type ClaimEarningsComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<ClaimEarningsMutation, ClaimEarningsMutationVariables>, 'mutation'>;

    export const ClaimEarningsComponent = (props: ClaimEarningsComponentProps) => (
      <ApolloReactComponents.Mutation<ClaimEarningsMutation, ClaimEarningsMutationVariables> mutation={ClaimEarningsDocument} {...props} />
    );
    

/**
 * __useClaimEarningsMutation__
 *
 * To run a mutation, you first call `useClaimEarningsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useClaimEarningsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [claimEarningsMutation, { data, loading, error }] = useClaimEarningsMutation({
 *   variables: {
 *   },
 * });
 */
export function useClaimEarningsMutation(baseOptions?: Apollo.MutationHookOptions<ClaimEarningsMutation, ClaimEarningsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ClaimEarningsMutation, ClaimEarningsMutationVariables>(ClaimEarningsDocument, options);
      }
export type ClaimEarningsMutationHookResult = ReturnType<typeof useClaimEarningsMutation>;
export type ClaimEarningsMutationResult = Apollo.MutationResult<ClaimEarningsMutation>;
export type ClaimEarningsMutationOptions = Apollo.BaseMutationOptions<ClaimEarningsMutation, ClaimEarningsMutationVariables>;
export const CreateGameAccountDocument = gql`
    mutation CreateGameAccount($topupProductId: Int!, $accountId: String!, $serverId: String, $inGameName: String, $userData: JSON!) {
  createGameAccount(
    topupProductId: $topupProductId
    accountId: $accountId
    serverId: $serverId
    inGameName: $inGameName
    userData: $userData
  ) {
    gameAccount {
      id
      accountId
      serverId
      inGameName
      approve
      displayName
      userData
      topupProduct {
        id
        title
        slug
      }
      createdAt
    }
    errors
  }
}
    `;
export type CreateGameAccountMutationFn = Apollo.MutationFunction<CreateGameAccountMutation, CreateGameAccountMutationVariables>;
export type CreateGameAccountComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<CreateGameAccountMutation, CreateGameAccountMutationVariables>, 'mutation'>;

    export const CreateGameAccountComponent = (props: CreateGameAccountComponentProps) => (
      <ApolloReactComponents.Mutation<CreateGameAccountMutation, CreateGameAccountMutationVariables> mutation={CreateGameAccountDocument} {...props} />
    );
    

/**
 * __useCreateGameAccountMutation__
 *
 * To run a mutation, you first call `useCreateGameAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateGameAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createGameAccountMutation, { data, loading, error }] = useCreateGameAccountMutation({
 *   variables: {
 *      topupProductId: // value for 'topupProductId'
 *      accountId: // value for 'accountId'
 *      serverId: // value for 'serverId'
 *      inGameName: // value for 'inGameName'
 *      userData: // value for 'userData'
 *   },
 * });
 */
export function useCreateGameAccountMutation(baseOptions?: Apollo.MutationHookOptions<CreateGameAccountMutation, CreateGameAccountMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateGameAccountMutation, CreateGameAccountMutationVariables>(CreateGameAccountDocument, options);
      }
export type CreateGameAccountMutationHookResult = ReturnType<typeof useCreateGameAccountMutation>;
export type CreateGameAccountMutationResult = Apollo.MutationResult<CreateGameAccountMutation>;
export type CreateGameAccountMutationOptions = Apollo.BaseMutationOptions<CreateGameAccountMutation, CreateGameAccountMutationVariables>;
export const CreateOrderDocument = gql`
    mutation CreateOrder($topupProductItemId: ID!, $transactionSignature: String!, $userData: JSON, $cryptoCurrency: String, $cryptoAmount: Float) {
  createOrder(
    topupProductItemId: $topupProductItemId
    transactionSignature: $transactionSignature
    userData: $userData
    cryptoCurrency: $cryptoCurrency
    cryptoAmount: $cryptoAmount
  ) {
    errors
    order {
      ...Order
    }
  }
}
    ${OrderFragmentDoc}`;
export type CreateOrderMutationFn = Apollo.MutationFunction<CreateOrderMutation, CreateOrderMutationVariables>;
export type CreateOrderComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<CreateOrderMutation, CreateOrderMutationVariables>, 'mutation'>;

    export const CreateOrderComponent = (props: CreateOrderComponentProps) => (
      <ApolloReactComponents.Mutation<CreateOrderMutation, CreateOrderMutationVariables> mutation={CreateOrderDocument} {...props} />
    );
    

/**
 * __useCreateOrderMutation__
 *
 * To run a mutation, you first call `useCreateOrderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOrderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOrderMutation, { data, loading, error }] = useCreateOrderMutation({
 *   variables: {
 *      topupProductItemId: // value for 'topupProductItemId'
 *      transactionSignature: // value for 'transactionSignature'
 *      userData: // value for 'userData'
 *      cryptoCurrency: // value for 'cryptoCurrency'
 *      cryptoAmount: // value for 'cryptoAmount'
 *   },
 * });
 */
export function useCreateOrderMutation(baseOptions?: Apollo.MutationHookOptions<CreateOrderMutation, CreateOrderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateOrderMutation, CreateOrderMutationVariables>(CreateOrderDocument, options);
      }
export type CreateOrderMutationHookResult = ReturnType<typeof useCreateOrderMutation>;
export type CreateOrderMutationResult = Apollo.MutationResult<CreateOrderMutation>;
export type CreateOrderMutationOptions = Apollo.BaseMutationOptions<CreateOrderMutation, CreateOrderMutationVariables>;
export const DeleteGameAccountDocument = gql`
    mutation DeleteGameAccount($gameAccountId: Int!) {
  deleteGameAccount(gameAccountId: $gameAccountId) {
    success
    errors
  }
}
    `;
export type DeleteGameAccountMutationFn = Apollo.MutationFunction<DeleteGameAccountMutation, DeleteGameAccountMutationVariables>;
export type DeleteGameAccountComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<DeleteGameAccountMutation, DeleteGameAccountMutationVariables>, 'mutation'>;

    export const DeleteGameAccountComponent = (props: DeleteGameAccountComponentProps) => (
      <ApolloReactComponents.Mutation<DeleteGameAccountMutation, DeleteGameAccountMutationVariables> mutation={DeleteGameAccountDocument} {...props} />
    );
    

/**
 * __useDeleteGameAccountMutation__
 *
 * To run a mutation, you first call `useDeleteGameAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteGameAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteGameAccountMutation, { data, loading, error }] = useDeleteGameAccountMutation({
 *   variables: {
 *      gameAccountId: // value for 'gameAccountId'
 *   },
 * });
 */
export function useDeleteGameAccountMutation(baseOptions?: Apollo.MutationHookOptions<DeleteGameAccountMutation, DeleteGameAccountMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteGameAccountMutation, DeleteGameAccountMutationVariables>(DeleteGameAccountDocument, options);
      }
export type DeleteGameAccountMutationHookResult = ReturnType<typeof useDeleteGameAccountMutation>;
export type DeleteGameAccountMutationResult = Apollo.MutationResult<DeleteGameAccountMutation>;
export type DeleteGameAccountMutationOptions = Apollo.BaseMutationOptions<DeleteGameAccountMutation, DeleteGameAccountMutationVariables>;
export const RemoveFavoriteDocument = gql`
    mutation RemoveFavorite($productId: ID!) {
  removeFavorite(productId: $productId) {
    topupProduct {
      id
      isFavorite
    }
    errors
  }
}
    `;
export type RemoveFavoriteMutationFn = Apollo.MutationFunction<RemoveFavoriteMutation, RemoveFavoriteMutationVariables>;
export type RemoveFavoriteComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<RemoveFavoriteMutation, RemoveFavoriteMutationVariables>, 'mutation'>;

    export const RemoveFavoriteComponent = (props: RemoveFavoriteComponentProps) => (
      <ApolloReactComponents.Mutation<RemoveFavoriteMutation, RemoveFavoriteMutationVariables> mutation={RemoveFavoriteDocument} {...props} />
    );
    

/**
 * __useRemoveFavoriteMutation__
 *
 * To run a mutation, you first call `useRemoveFavoriteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveFavoriteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeFavoriteMutation, { data, loading, error }] = useRemoveFavoriteMutation({
 *   variables: {
 *      productId: // value for 'productId'
 *   },
 * });
 */
export function useRemoveFavoriteMutation(baseOptions?: Apollo.MutationHookOptions<RemoveFavoriteMutation, RemoveFavoriteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveFavoriteMutation, RemoveFavoriteMutationVariables>(RemoveFavoriteDocument, options);
      }
export type RemoveFavoriteMutationHookResult = ReturnType<typeof useRemoveFavoriteMutation>;
export type RemoveFavoriteMutationResult = Apollo.MutationResult<RemoveFavoriteMutation>;
export type RemoveFavoriteMutationOptions = Apollo.BaseMutationOptions<RemoveFavoriteMutation, RemoveFavoriteMutationVariables>;
export const SendEmailVerificationCodeDocument = gql`
    mutation SendEmailVerificationCode($email: String!) {
  sendEmailVerificationCode(email: $email) {
    success
    message
    errors
  }
}
    `;
export type SendEmailVerificationCodeMutationFn = Apollo.MutationFunction<SendEmailVerificationCodeMutation, SendEmailVerificationCodeMutationVariables>;
export type SendEmailVerificationCodeComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<SendEmailVerificationCodeMutation, SendEmailVerificationCodeMutationVariables>, 'mutation'>;

    export const SendEmailVerificationCodeComponent = (props: SendEmailVerificationCodeComponentProps) => (
      <ApolloReactComponents.Mutation<SendEmailVerificationCodeMutation, SendEmailVerificationCodeMutationVariables> mutation={SendEmailVerificationCodeDocument} {...props} />
    );
    

/**
 * __useSendEmailVerificationCodeMutation__
 *
 * To run a mutation, you first call `useSendEmailVerificationCodeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSendEmailVerificationCodeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sendEmailVerificationCodeMutation, { data, loading, error }] = useSendEmailVerificationCodeMutation({
 *   variables: {
 *      email: // value for 'email'
 *   },
 * });
 */
export function useSendEmailVerificationCodeMutation(baseOptions?: Apollo.MutationHookOptions<SendEmailVerificationCodeMutation, SendEmailVerificationCodeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SendEmailVerificationCodeMutation, SendEmailVerificationCodeMutationVariables>(SendEmailVerificationCodeDocument, options);
      }
export type SendEmailVerificationCodeMutationHookResult = ReturnType<typeof useSendEmailVerificationCodeMutation>;
export type SendEmailVerificationCodeMutationResult = Apollo.MutationResult<SendEmailVerificationCodeMutation>;
export type SendEmailVerificationCodeMutationOptions = Apollo.BaseMutationOptions<SendEmailVerificationCodeMutation, SendEmailVerificationCodeMutationVariables>;
export const UpdateEmailDocument = gql`
    mutation UpdateEmail($newEmail: String!) {
  updateEmail(newEmail: $newEmail) {
    success
    message
    errors
  }
}
    `;
export type UpdateEmailMutationFn = Apollo.MutationFunction<UpdateEmailMutation, UpdateEmailMutationVariables>;
export type UpdateEmailComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<UpdateEmailMutation, UpdateEmailMutationVariables>, 'mutation'>;

    export const UpdateEmailComponent = (props: UpdateEmailComponentProps) => (
      <ApolloReactComponents.Mutation<UpdateEmailMutation, UpdateEmailMutationVariables> mutation={UpdateEmailDocument} {...props} />
    );
    

/**
 * __useUpdateEmailMutation__
 *
 * To run a mutation, you first call `useUpdateEmailMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateEmailMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateEmailMutation, { data, loading, error }] = useUpdateEmailMutation({
 *   variables: {
 *      newEmail: // value for 'newEmail'
 *   },
 * });
 */
export function useUpdateEmailMutation(baseOptions?: Apollo.MutationHookOptions<UpdateEmailMutation, UpdateEmailMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateEmailMutation, UpdateEmailMutationVariables>(UpdateEmailDocument, options);
      }
export type UpdateEmailMutationHookResult = ReturnType<typeof useUpdateEmailMutation>;
export type UpdateEmailMutationResult = Apollo.MutationResult<UpdateEmailMutation>;
export type UpdateEmailMutationOptions = Apollo.BaseMutationOptions<UpdateEmailMutation, UpdateEmailMutationVariables>;
export const ValidateGameAccountDocument = gql`
    mutation ValidateGameAccount($gameAccountId: Int!) {
  validateGameAccountMutation(gameAccountId: $gameAccountId) {
    gameAccount {
      id
      accountId
      serverId
      inGameName
      approve
      displayName
    }
    success
    errors
  }
}
    `;
export type ValidateGameAccountMutationFn = Apollo.MutationFunction<ValidateGameAccountMutation, ValidateGameAccountMutationVariables>;
export type ValidateGameAccountComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<ValidateGameAccountMutation, ValidateGameAccountMutationVariables>, 'mutation'>;

    export const ValidateGameAccountComponent = (props: ValidateGameAccountComponentProps) => (
      <ApolloReactComponents.Mutation<ValidateGameAccountMutation, ValidateGameAccountMutationVariables> mutation={ValidateGameAccountDocument} {...props} />
    );
    

/**
 * __useValidateGameAccountMutation__
 *
 * To run a mutation, you first call `useValidateGameAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useValidateGameAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [validateGameAccountMutation, { data, loading, error }] = useValidateGameAccountMutation({
 *   variables: {
 *      gameAccountId: // value for 'gameAccountId'
 *   },
 * });
 */
export function useValidateGameAccountMutation(baseOptions?: Apollo.MutationHookOptions<ValidateGameAccountMutation, ValidateGameAccountMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ValidateGameAccountMutation, ValidateGameAccountMutationVariables>(ValidateGameAccountDocument, options);
      }
export type ValidateGameAccountMutationHookResult = ReturnType<typeof useValidateGameAccountMutation>;
export type ValidateGameAccountMutationResult = Apollo.MutationResult<ValidateGameAccountMutation>;
export type ValidateGameAccountMutationOptions = Apollo.BaseMutationOptions<ValidateGameAccountMutation, ValidateGameAccountMutationVariables>;
export const VerifyEmailDocument = gql`
    mutation VerifyEmail($code: String!) {
  verifyEmail(code: $code) {
    success
    message
    errors
    user {
      ...UserSession
    }
  }
}
    ${UserSessionFragmentDoc}`;
export type VerifyEmailMutationFn = Apollo.MutationFunction<VerifyEmailMutation, VerifyEmailMutationVariables>;
export type VerifyEmailComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<VerifyEmailMutation, VerifyEmailMutationVariables>, 'mutation'>;

    export const VerifyEmailComponent = (props: VerifyEmailComponentProps) => (
      <ApolloReactComponents.Mutation<VerifyEmailMutation, VerifyEmailMutationVariables> mutation={VerifyEmailDocument} {...props} />
    );
    

/**
 * __useVerifyEmailMutation__
 *
 * To run a mutation, you first call `useVerifyEmailMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useVerifyEmailMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [verifyEmailMutation, { data, loading, error }] = useVerifyEmailMutation({
 *   variables: {
 *      code: // value for 'code'
 *   },
 * });
 */
export function useVerifyEmailMutation(baseOptions?: Apollo.MutationHookOptions<VerifyEmailMutation, VerifyEmailMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<VerifyEmailMutation, VerifyEmailMutationVariables>(VerifyEmailDocument, options);
      }
export type VerifyEmailMutationHookResult = ReturnType<typeof useVerifyEmailMutation>;
export type VerifyEmailMutationResult = Apollo.MutationResult<VerifyEmailMutation>;
export type VerifyEmailMutationOptions = Apollo.BaseMutationOptions<VerifyEmailMutation, VerifyEmailMutationVariables>;
export const GetActiveVouchersDocument = gql`
    query GetActiveVouchers {
  activeVouchers {
    id
    voucherType
    discountPercent
    expiresAt
    used
    active
    createdAt
  }
}
    `;
export type GetActiveVouchersComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<GetActiveVouchersQuery, GetActiveVouchersQueryVariables>, 'query'>;

    export const GetActiveVouchersComponent = (props: GetActiveVouchersComponentProps) => (
      <ApolloReactComponents.Query<GetActiveVouchersQuery, GetActiveVouchersQueryVariables> query={GetActiveVouchersDocument} {...props} />
    );
    

/**
 * __useGetActiveVouchersQuery__
 *
 * To run a query within a React component, call `useGetActiveVouchersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetActiveVouchersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetActiveVouchersQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetActiveVouchersQuery(baseOptions?: Apollo.QueryHookOptions<GetActiveVouchersQuery, GetActiveVouchersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetActiveVouchersQuery, GetActiveVouchersQueryVariables>(GetActiveVouchersDocument, options);
      }
export function useGetActiveVouchersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetActiveVouchersQuery, GetActiveVouchersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetActiveVouchersQuery, GetActiveVouchersQueryVariables>(GetActiveVouchersDocument, options);
        }
export function useGetActiveVouchersSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetActiveVouchersQuery, GetActiveVouchersQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetActiveVouchersQuery, GetActiveVouchersQueryVariables>(GetActiveVouchersDocument, options);
        }
export type GetActiveVouchersQueryHookResult = ReturnType<typeof useGetActiveVouchersQuery>;
export type GetActiveVouchersLazyQueryHookResult = ReturnType<typeof useGetActiveVouchersLazyQuery>;
export type GetActiveVouchersSuspenseQueryHookResult = ReturnType<typeof useGetActiveVouchersSuspenseQuery>;
export type GetActiveVouchersQueryResult = Apollo.QueryResult<GetActiveVouchersQuery, GetActiveVouchersQueryVariables>;
export const CurrentUserDocument = gql`
    query CurrentUser {
  currentUser {
    ...UserSession
  }
}
    ${UserSessionFragmentDoc}`;
export type CurrentUserComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<CurrentUserQuery, CurrentUserQueryVariables>, 'query'>;

    export const CurrentUserComponent = (props: CurrentUserComponentProps) => (
      <ApolloReactComponents.Query<CurrentUserQuery, CurrentUserQueryVariables> query={CurrentUserDocument} {...props} />
    );
    

/**
 * __useCurrentUserQuery__
 *
 * To run a query within a React component, call `useCurrentUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useCurrentUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCurrentUserQuery({
 *   variables: {
 *   },
 * });
 */
export function useCurrentUserQuery(baseOptions?: Apollo.QueryHookOptions<CurrentUserQuery, CurrentUserQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CurrentUserQuery, CurrentUserQueryVariables>(CurrentUserDocument, options);
      }
export function useCurrentUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CurrentUserQuery, CurrentUserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CurrentUserQuery, CurrentUserQueryVariables>(CurrentUserDocument, options);
        }
export function useCurrentUserSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<CurrentUserQuery, CurrentUserQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CurrentUserQuery, CurrentUserQueryVariables>(CurrentUserDocument, options);
        }
export type CurrentUserQueryHookResult = ReturnType<typeof useCurrentUserQuery>;
export type CurrentUserLazyQueryHookResult = ReturnType<typeof useCurrentUserLazyQuery>;
export type CurrentUserSuspenseQueryHookResult = ReturnType<typeof useCurrentUserSuspenseQuery>;
export type CurrentUserQueryResult = Apollo.QueryResult<CurrentUserQuery, CurrentUserQueryVariables>;
export const MyFavoritesDocument = gql`
    query MyFavorites {
  myFavorites {
    ...TopupProductList
  }
}
    ${TopupProductListFragmentDoc}`;
export type MyFavoritesComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<MyFavoritesQuery, MyFavoritesQueryVariables>, 'query'>;

    export const MyFavoritesComponent = (props: MyFavoritesComponentProps) => (
      <ApolloReactComponents.Query<MyFavoritesQuery, MyFavoritesQueryVariables> query={MyFavoritesDocument} {...props} />
    );
    

/**
 * __useMyFavoritesQuery__
 *
 * To run a query within a React component, call `useMyFavoritesQuery` and pass it any options that fit your needs.
 * When your component renders, `useMyFavoritesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyFavoritesQuery({
 *   variables: {
 *   },
 * });
 */
export function useMyFavoritesQuery(baseOptions?: Apollo.QueryHookOptions<MyFavoritesQuery, MyFavoritesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MyFavoritesQuery, MyFavoritesQueryVariables>(MyFavoritesDocument, options);
      }
export function useMyFavoritesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MyFavoritesQuery, MyFavoritesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MyFavoritesQuery, MyFavoritesQueryVariables>(MyFavoritesDocument, options);
        }
export function useMyFavoritesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<MyFavoritesQuery, MyFavoritesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<MyFavoritesQuery, MyFavoritesQueryVariables>(MyFavoritesDocument, options);
        }
export type MyFavoritesQueryHookResult = ReturnType<typeof useMyFavoritesQuery>;
export type MyFavoritesLazyQueryHookResult = ReturnType<typeof useMyFavoritesLazyQuery>;
export type MyFavoritesSuspenseQueryHookResult = ReturnType<typeof useMyFavoritesSuspenseQuery>;
export type MyFavoritesQueryResult = Apollo.QueryResult<MyFavoritesQuery, MyFavoritesQueryVariables>;
export const MyGameAccountsDocument = gql`
    query MyGameAccounts($topupProductId: Int, $approvedOnly: Boolean) {
  myGameAccounts(topupProductId: $topupProductId, approvedOnly: $approvedOnly) {
    id
    accountId
    serverId
    inGameName
    approve
    displayName
    status
    userData
    topupProduct {
      id
      title
      slug
    }
    createdAt
    updatedAt
  }
}
    `;
export type MyGameAccountsComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<MyGameAccountsQuery, MyGameAccountsQueryVariables>, 'query'>;

    export const MyGameAccountsComponent = (props: MyGameAccountsComponentProps) => (
      <ApolloReactComponents.Query<MyGameAccountsQuery, MyGameAccountsQueryVariables> query={MyGameAccountsDocument} {...props} />
    );
    

/**
 * __useMyGameAccountsQuery__
 *
 * To run a query within a React component, call `useMyGameAccountsQuery` and pass it any options that fit your needs.
 * When your component renders, `useMyGameAccountsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyGameAccountsQuery({
 *   variables: {
 *      topupProductId: // value for 'topupProductId'
 *      approvedOnly: // value for 'approvedOnly'
 *   },
 * });
 */
export function useMyGameAccountsQuery(baseOptions?: Apollo.QueryHookOptions<MyGameAccountsQuery, MyGameAccountsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MyGameAccountsQuery, MyGameAccountsQueryVariables>(MyGameAccountsDocument, options);
      }
export function useMyGameAccountsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MyGameAccountsQuery, MyGameAccountsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MyGameAccountsQuery, MyGameAccountsQueryVariables>(MyGameAccountsDocument, options);
        }
export function useMyGameAccountsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<MyGameAccountsQuery, MyGameAccountsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<MyGameAccountsQuery, MyGameAccountsQueryVariables>(MyGameAccountsDocument, options);
        }
export type MyGameAccountsQueryHookResult = ReturnType<typeof useMyGameAccountsQuery>;
export type MyGameAccountsLazyQueryHookResult = ReturnType<typeof useMyGameAccountsLazyQuery>;
export type MyGameAccountsSuspenseQueryHookResult = ReturnType<typeof useMyGameAccountsSuspenseQuery>;
export type MyGameAccountsQueryResult = Apollo.QueryResult<MyGameAccountsQuery, MyGameAccountsQueryVariables>;
export const MyOrdersDocument = gql`
    query MyOrders($limit: Int) {
  myOrders(limit: $limit) {
    ...Order
  }
}
    ${OrderFragmentDoc}`;
export type MyOrdersComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<MyOrdersQuery, MyOrdersQueryVariables>, 'query'>;

    export const MyOrdersComponent = (props: MyOrdersComponentProps) => (
      <ApolloReactComponents.Query<MyOrdersQuery, MyOrdersQueryVariables> query={MyOrdersDocument} {...props} />
    );
    

/**
 * __useMyOrdersQuery__
 *
 * To run a query within a React component, call `useMyOrdersQuery` and pass it any options that fit your needs.
 * When your component renders, `useMyOrdersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyOrdersQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useMyOrdersQuery(baseOptions?: Apollo.QueryHookOptions<MyOrdersQuery, MyOrdersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MyOrdersQuery, MyOrdersQueryVariables>(MyOrdersDocument, options);
      }
export function useMyOrdersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MyOrdersQuery, MyOrdersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MyOrdersQuery, MyOrdersQueryVariables>(MyOrdersDocument, options);
        }
export function useMyOrdersSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<MyOrdersQuery, MyOrdersQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<MyOrdersQuery, MyOrdersQueryVariables>(MyOrdersDocument, options);
        }
export type MyOrdersQueryHookResult = ReturnType<typeof useMyOrdersQuery>;
export type MyOrdersLazyQueryHookResult = ReturnType<typeof useMyOrdersLazyQuery>;
export type MyOrdersSuspenseQueryHookResult = ReturnType<typeof useMyOrdersSuspenseQuery>;
export type MyOrdersQueryResult = Apollo.QueryResult<MyOrdersQuery, MyOrdersQueryVariables>;
export const OrderDocument = gql`
    query Order($id: ID!) {
  order(id: $id) {
    ...Order
  }
}
    ${OrderFragmentDoc}`;
export type OrderComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<OrderQuery, OrderQueryVariables>, 'query'> & ({ variables: OrderQueryVariables; skip?: boolean; } | { skip: boolean; });

    export const OrderComponent = (props: OrderComponentProps) => (
      <ApolloReactComponents.Query<OrderQuery, OrderQueryVariables> query={OrderDocument} {...props} />
    );
    

/**
 * __useOrderQuery__
 *
 * To run a query within a React component, call `useOrderQuery` and pass it any options that fit your needs.
 * When your component renders, `useOrderQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOrderQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useOrderQuery(baseOptions: Apollo.QueryHookOptions<OrderQuery, OrderQueryVariables> & ({ variables: OrderQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<OrderQuery, OrderQueryVariables>(OrderDocument, options);
      }
export function useOrderLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<OrderQuery, OrderQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<OrderQuery, OrderQueryVariables>(OrderDocument, options);
        }
export function useOrderSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<OrderQuery, OrderQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<OrderQuery, OrderQueryVariables>(OrderDocument, options);
        }
export type OrderQueryHookResult = ReturnType<typeof useOrderQuery>;
export type OrderLazyQueryHookResult = ReturnType<typeof useOrderLazyQuery>;
export type OrderSuspenseQueryHookResult = ReturnType<typeof useOrderSuspenseQuery>;
export type OrderQueryResult = Apollo.QueryResult<OrderQuery, OrderQueryVariables>;
export const GetReferralCodeDocument = gql`
    query GetReferralCode {
  referralCode {
    id
    code
    totalUses
    totalEarnings
    createdAt
  }
}
    `;
export type GetReferralCodeComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<GetReferralCodeQuery, GetReferralCodeQueryVariables>, 'query'>;

    export const GetReferralCodeComponent = (props: GetReferralCodeComponentProps) => (
      <ApolloReactComponents.Query<GetReferralCodeQuery, GetReferralCodeQueryVariables> query={GetReferralCodeDocument} {...props} />
    );
    

/**
 * __useGetReferralCodeQuery__
 *
 * To run a query within a React component, call `useGetReferralCodeQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetReferralCodeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetReferralCodeQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetReferralCodeQuery(baseOptions?: Apollo.QueryHookOptions<GetReferralCodeQuery, GetReferralCodeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetReferralCodeQuery, GetReferralCodeQueryVariables>(GetReferralCodeDocument, options);
      }
export function useGetReferralCodeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetReferralCodeQuery, GetReferralCodeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetReferralCodeQuery, GetReferralCodeQueryVariables>(GetReferralCodeDocument, options);
        }
export function useGetReferralCodeSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetReferralCodeQuery, GetReferralCodeQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetReferralCodeQuery, GetReferralCodeQueryVariables>(GetReferralCodeDocument, options);
        }
export type GetReferralCodeQueryHookResult = ReturnType<typeof useGetReferralCodeQuery>;
export type GetReferralCodeLazyQueryHookResult = ReturnType<typeof useGetReferralCodeLazyQuery>;
export type GetReferralCodeSuspenseQueryHookResult = ReturnType<typeof useGetReferralCodeSuspenseQuery>;
export type GetReferralCodeQueryResult = Apollo.QueryResult<GetReferralCodeQuery, GetReferralCodeQueryVariables>;
export const GetReferralStatsDocument = gql`
    query GetReferralStats {
  referralStats {
    referralCode
    totalReferrals
    totalEarnings
    claimableEarnings
    claimedEarnings
    recentEarnings {
      id
      orderAmount
      commissionPercent
      commissionAmount
      currency
      status
      claimedAt
      createdAt
    }
  }
}
    `;
export type GetReferralStatsComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<GetReferralStatsQuery, GetReferralStatsQueryVariables>, 'query'>;

    export const GetReferralStatsComponent = (props: GetReferralStatsComponentProps) => (
      <ApolloReactComponents.Query<GetReferralStatsQuery, GetReferralStatsQueryVariables> query={GetReferralStatsDocument} {...props} />
    );
    

/**
 * __useGetReferralStatsQuery__
 *
 * To run a query within a React component, call `useGetReferralStatsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetReferralStatsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetReferralStatsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetReferralStatsQuery(baseOptions?: Apollo.QueryHookOptions<GetReferralStatsQuery, GetReferralStatsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetReferralStatsQuery, GetReferralStatsQueryVariables>(GetReferralStatsDocument, options);
      }
export function useGetReferralStatsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetReferralStatsQuery, GetReferralStatsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetReferralStatsQuery, GetReferralStatsQueryVariables>(GetReferralStatsDocument, options);
        }
export function useGetReferralStatsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetReferralStatsQuery, GetReferralStatsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetReferralStatsQuery, GetReferralStatsQueryVariables>(GetReferralStatsDocument, options);
        }
export type GetReferralStatsQueryHookResult = ReturnType<typeof useGetReferralStatsQuery>;
export type GetReferralStatsLazyQueryHookResult = ReturnType<typeof useGetReferralStatsLazyQuery>;
export type GetReferralStatsSuspenseQueryHookResult = ReturnType<typeof useGetReferralStatsSuspenseQuery>;
export type GetReferralStatsQueryResult = Apollo.QueryResult<GetReferralStatsQuery, GetReferralStatsQueryVariables>;
export const TopupProductsDocument = gql`
    query TopupProducts($categoryId: ID, $page: Int!, $search: String, $perPage: Int, $countryCode: String, $forStore: Boolean, $genre: String) {
  topupProducts(
    categoryId: $categoryId
    page: $page
    search: $search
    perPage: $perPage
    countryCode: $countryCode
    forStore: $forStore
    genre: $genre
  ) {
    ...TopupProductList
  }
}
    ${TopupProductListFragmentDoc}`;
export type TopupProductsComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<TopupProductsQuery, TopupProductsQueryVariables>, 'query'> & ({ variables: TopupProductsQueryVariables; skip?: boolean; } | { skip: boolean; });

    export const TopupProductsComponent = (props: TopupProductsComponentProps) => (
      <ApolloReactComponents.Query<TopupProductsQuery, TopupProductsQueryVariables> query={TopupProductsDocument} {...props} />
    );
    

/**
 * __useTopupProductsQuery__
 *
 * To run a query within a React component, call `useTopupProductsQuery` and pass it any options that fit your needs.
 * When your component renders, `useTopupProductsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTopupProductsQuery({
 *   variables: {
 *      categoryId: // value for 'categoryId'
 *      page: // value for 'page'
 *      search: // value for 'search'
 *      perPage: // value for 'perPage'
 *      countryCode: // value for 'countryCode'
 *      forStore: // value for 'forStore'
 *      genre: // value for 'genre'
 *   },
 * });
 */
export function useTopupProductsQuery(baseOptions: Apollo.QueryHookOptions<TopupProductsQuery, TopupProductsQueryVariables> & ({ variables: TopupProductsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TopupProductsQuery, TopupProductsQueryVariables>(TopupProductsDocument, options);
      }
export function useTopupProductsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TopupProductsQuery, TopupProductsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TopupProductsQuery, TopupProductsQueryVariables>(TopupProductsDocument, options);
        }
export function useTopupProductsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<TopupProductsQuery, TopupProductsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<TopupProductsQuery, TopupProductsQueryVariables>(TopupProductsDocument, options);
        }
export type TopupProductsQueryHookResult = ReturnType<typeof useTopupProductsQuery>;
export type TopupProductsLazyQueryHookResult = ReturnType<typeof useTopupProductsLazyQuery>;
export type TopupProductsSuspenseQueryHookResult = ReturnType<typeof useTopupProductsSuspenseQuery>;
export type TopupProductsQueryResult = Apollo.QueryResult<TopupProductsQuery, TopupProductsQueryVariables>;
export const TopupProductDocument = gql`
    query TopupProduct($id: ID, $slug: String) {
  topupProduct(id: $id, slug: $slug) {
    ...TopupProduct
  }
}
    ${TopupProductFragmentDoc}`;
export type TopupProductComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<TopupProductQuery, TopupProductQueryVariables>, 'query'>;

    export const TopupProductComponent = (props: TopupProductComponentProps) => (
      <ApolloReactComponents.Query<TopupProductQuery, TopupProductQueryVariables> query={TopupProductDocument} {...props} />
    );
    

/**
 * __useTopupProductQuery__
 *
 * To run a query within a React component, call `useTopupProductQuery` and pass it any options that fit your needs.
 * When your component renders, `useTopupProductQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTopupProductQuery({
 *   variables: {
 *      id: // value for 'id'
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useTopupProductQuery(baseOptions?: Apollo.QueryHookOptions<TopupProductQuery, TopupProductQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TopupProductQuery, TopupProductQueryVariables>(TopupProductDocument, options);
      }
export function useTopupProductLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TopupProductQuery, TopupProductQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TopupProductQuery, TopupProductQueryVariables>(TopupProductDocument, options);
        }
export function useTopupProductSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<TopupProductQuery, TopupProductQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<TopupProductQuery, TopupProductQueryVariables>(TopupProductDocument, options);
        }
export type TopupProductQueryHookResult = ReturnType<typeof useTopupProductQuery>;
export type TopupProductLazyQueryHookResult = ReturnType<typeof useTopupProductLazyQuery>;
export type TopupProductSuspenseQueryHookResult = ReturnType<typeof useTopupProductSuspenseQuery>;
export type TopupProductQueryResult = Apollo.QueryResult<TopupProductQuery, TopupProductQueryVariables>;
export const StoreTopupProductDocument = gql`
    query StoreTopupProduct($id: ID, $slug: String) {
  topupProduct(id: $id, slug: $slug) {
    ...TopupProductDetail
  }
}
    ${TopupProductDetailFragmentDoc}`;
export type StoreTopupProductComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<StoreTopupProductQuery, StoreTopupProductQueryVariables>, 'query'>;

    export const StoreTopupProductComponent = (props: StoreTopupProductComponentProps) => (
      <ApolloReactComponents.Query<StoreTopupProductQuery, StoreTopupProductQueryVariables> query={StoreTopupProductDocument} {...props} />
    );
    

/**
 * __useStoreTopupProductQuery__
 *
 * To run a query within a React component, call `useStoreTopupProductQuery` and pass it any options that fit your needs.
 * When your component renders, `useStoreTopupProductQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStoreTopupProductQuery({
 *   variables: {
 *      id: // value for 'id'
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useStoreTopupProductQuery(baseOptions?: Apollo.QueryHookOptions<StoreTopupProductQuery, StoreTopupProductQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StoreTopupProductQuery, StoreTopupProductQueryVariables>(StoreTopupProductDocument, options);
      }
export function useStoreTopupProductLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StoreTopupProductQuery, StoreTopupProductQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StoreTopupProductQuery, StoreTopupProductQueryVariables>(StoreTopupProductDocument, options);
        }
export function useStoreTopupProductSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<StoreTopupProductQuery, StoreTopupProductQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StoreTopupProductQuery, StoreTopupProductQueryVariables>(StoreTopupProductDocument, options);
        }
export type StoreTopupProductQueryHookResult = ReturnType<typeof useStoreTopupProductQuery>;
export type StoreTopupProductLazyQueryHookResult = ReturnType<typeof useStoreTopupProductLazyQuery>;
export type StoreTopupProductSuspenseQueryHookResult = ReturnType<typeof useStoreTopupProductSuspenseQuery>;
export type StoreTopupProductQueryResult = Apollo.QueryResult<StoreTopupProductQuery, StoreTopupProductQueryVariables>;